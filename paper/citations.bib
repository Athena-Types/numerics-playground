@article{satire,
      title={Satire: Computing Rigorous Bounds for Floating-Point Rounding Error in Mixed-Precision Loop-Free Programs}, 
      author={Tanmay Tirpankar and Arnab Das and Ganesh Gopalakrishnan},
      year={2025},
      eprint={2503.05924},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2503.05924}, 
}
@article{fptaylor,
  author = {Solovyev, Alexey and Baranowski, Marek S. and Briggs, Ian and Jacobsen, Charles and Rakamari\'{c}, Zvonimir and Gopalakrishnan, Ganesh},
  title = {Rigorous Estimation of Floating-Point Round-Off Errors with Symbolic Taylor Expansions},
  year = {2018},
  issue_date = {March 2019},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {41},
  number = {1},
  issn = {0164-0925},
  url = {https://doi.org/10.1145/3230733},
  doi = {10.1145/3230733},
  abstract = {Rigorous estimation of maximum floating-point round-off errors is an important capability central to many formal verification tools. Unfortunately, available techniques for this task often provide very pessimistic overestimates, causing unnecessary verification failure. We have developed a new approach called Symbolic Taylor Expansions that avoids these problems, and implemented a new tool called FPTaylor embodying this approach. Key to our approach is the use of rigorous global optimization, instead of the more familiar interval arithmetic, affine arithmetic, and/or SMT solvers. FPTaylor emits per-instance analysis certificates in the form of HOL Light proofs that can be machine checked.In this article, we present the basic ideas behind Symbolic Taylor Expansions in detail. We also survey as well as thoroughly evaluate six tool families, namely, Gappa (two tool options studied), Fluctuat, PRECiSA, Real2Float, Rosa, and FPTaylor (two tool options studied) on 24 examples, running on the same machine, and taking care to find the best options for running each of these tools. This study demonstrates that FPTaylor estimates round-off errors within much tighter bounds compared to other tools on a significant number of case studies. We also release FPTaylor along with our benchmarks, thus contributing to future studies and tool development in this area.},
  journal = {ACM Trans. Program. Lang. Syst.},
  month = dec,
  articleno = {2},
  numpages = {39},
  keywords = {Floating-point arithmetic, IEEE floating-point standard, formal verification, global optimization, mixed-precision arithmetic, round-off error}
}
@article{gappa,
  author = {Daumas, Marc and Melquiond, Guillaume},
  title = {Certification of bounds on expressions involving rounded operators},
  year = {2010},
  issue_date = {January 2010},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {37},
  number = {1},
  issn = {0098-3500},
  url = {https://doi.org/10.1145/1644001.1644003},
  doi = {10.1145/1644001.1644003},
  abstract = {Gappa is a tool designed to formally verify the correctness of numerical software and hardware. It uses interval arithmetic and forward error analysis to bound mathematical expressions that involve rounded as well as exact operators. It then generates a theorem and its proof for each verified enclosure. This proof can be automatically checked with a proof assistant, such as Coq or HOL Light. It relies on a large companion library of facts that we have developed. This Coq library provides theorems dealing with addition, multiplication, division, and square root, for both fixed- and floating-point arithmetics. Gappa uses multiple-precision dyadic fractions for the endpoints of intervals and performs forward error analysis on rounded operators when necessary. When asked, Gappa reports the best bounds it is able to reach for a given expression in a given context. This feature can be used to identify where the set of facts and automatic techniques implemented in Gappa becomes insufficient. Gappa handles seamlessly additional properties expressed as interval properties or rewriting rules in order to establish more intricate bounds. Recent work showed that Gappa is suited to discharge proof obligations generated for small pieces of software. They may be produced by third-party tools and the first applications of Gappa use proof obligations written by designers or obtained from traces of execution.},
  journal = {ACM Trans. Math. Softw.},
  month = jan,
  articleno = {2},
  numpages = {20},
  keywords = {Coq, Forward error analysis, HOL Light, PVS, dyadic fraction, floating point, interval arithmetic, proof obligation, proof system}
}
@article{numfuzz,
  author = {Kellison, Ariel E. and Hsu, Justin},
  title = {Numerical Fuzz: A Type System for Rounding Error Analysis},
  year = {2024},
  issue_date = {June 2024},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {8},
  number = {PLDI},
  url = {https://doi.org/10.1145/3656456},
  doi = {10.1145/3656456},
  abstract = {Algorithms operating on real numbers are implemented as floating-point computations in practice, but floatingpoint operations introduce roundoff errors that can degrade the accuracy of the result. We propose Λnum, a functional programming language with a type system that can express quantitative bounds on roundoff error. Our type system combines a sensitivity analysis, enforced through a linear typing discipline, with a novel graded monad to track the accumulation of roundoff errors. We prove that our type system is sound by relating the denotational semantics of our language to the exact and floating-point operational semantics.To demonstrate our system, we instantiate Λnum with error metrics proposed in the numerical analysis literature and we show how to incorporate rounding operations that faithfully model aspects of the IEEE 754 floating-point standard. To show that Λnum can be a useful tool for automated error analysis, we develop a prototype implementation for Λnum that infers error bounds that are competitive with existing tools, while often running significantly faster. Finally, we consider semantic extensions of our graded monad to bound error under more complex rounding behaviors, such as non-deterministic and randomized rounding.},
  journal = {Proc. ACM Program. Lang.},
  month = jun,
  articleno = {226},
  numpages = {25},
  keywords = {Floating point, Roundoff error, Linear type systems}
}
@article{bean,
  author = {Kellison, Ariel E. and Zielinski, Laura and Bindel, David and Hsu, Justin},
  title = {Bean: A Language for Backward Error Analysis},
  year = {2025},
  issue_date = {June 2025},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {9},
  number = {PLDI},
  url = {https://doi.org/10.1145/3729324},
  doi = {10.1145/3729324},
  abstract = {Backward error analysis offers a method for assessing the quality of numerical programs in the presence of floating-point rounding errors. However, techniques from the numerical analysis literature for quantifying backward error require substantial human effort, and there are currently no tools or automated methods for statically deriving sound backward error bounds. To address this gap, we propose Bean, a typed first-order programming language designed to express quantitative bounds on backward error. Bean’s type system combines a graded coeffect system with strict linearity to soundly track the flow of backward error through programs. We prove the soundness of our system using a novel categorical semantics, where every Bean program denotes a triple of related transformations that together satisfy a backward error guarantee. To illustrate Bean’s potential as a practical tool for automated backward error analysis, we implement a variety of standard algorithms from numerical linear algebra in Bean, establishing fine-grained backward error bounds via typing in a compositional style. We also develop a prototype implementation of Bean that infers backward error bounds automatically. Our evaluation shows that these inferred bounds match worst-case theoretical relative backward error bounds from the literature, underscoring Bean’s utility in validating a key property of numerical programs: numerical stability.},
  journal = {Proc. ACM Program. Lang.},
  month = jun,
  articleno = {221},
  numpages = {25},
  keywords = {Backward error, Floating point, Linear type systems}
}
