\section{Type inference} \label{sec:inference}
Our type inference algorithm computes the type sensitivity and inference
analysis developed in \cite{numfuzz} in addition to inferring polymoprhic bound
to generate a valid typing derivation of the program in \bnd{\Lang}.
Automatically inferring polymorphic bounds reduces the user annotation burden.
To define the type inference problem, we first define a sensitivity erasure
$-^{\bullet}$ over typing contexts and a bound erasure $-^{\bnd{\bullet}}$ over
types and terms. We will then define type inference as inferring sensitivities
and bounds over erased, well-typed terms.

\begin{definition}[Sensitivity erasure]
For a fully annotated typing context $\Gamma$, a fully erased typing context
$\Gamma^{\bnd{\bullet}} = \Gamma \circ (map \ \pi_2)$ with all sensitivity and
information erased.
% TODO: find a better way to define sensitivty erasure 
\end{definition}

\begin{definition}[Bound erasure]
We define bound erasure ($-^{\bnd{\bullet}}$) over types and terms below:
\begin{equation}
\begin{aligned}[c]
\textbf{unit}^{\bnd{\bullet}} &\triangleq \textbf{unit} \\
\textbf{num}_i^{\bnd{\bullet}} &\triangleq \textbf{num} \\
(\forall \epsilon . \tau)^{\bnd{\bullet}} &\triangleq \tau^{\bnd{\bullet}} \\
(\tau_0 \times \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \times \tau_1^{\bnd{\bullet}}) \\
\end{aligned}
\begin{aligned}[c]
(!_s \tau)^{\bnd{\bullet}} &\triangleq !_s \tau^{\bnd{\bullet}} \\
(M_u \tau)^{\bnd{\bullet}} &\triangleq M_u \tau^{\bnd{\bullet}} \\
(\tau_0 \otimes \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \otimes \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \multimap \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \multimap \tau_1^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation}

We similarly define an erasure operation for terms:

\begin{equation*}
\begin{aligned}[c]
v^{\bnd{\bullet}} &\triangleq v \\
x^{\bnd{\bullet}} &\triangleq x \\
(\textbf{op} \ e)^{\bnd{\bullet}} &\triangleq \textbf{op} \ e^{\bnd{\bullet}} \\
(e \ f)^{\bnd{\bullet}} &\triangleq e^{\bnd{\bullet}} \ f^{\bnd{\bullet}} \\
(\textbf{rnd} \ e)^{\bnd{\bullet}} &\triangleq \textbf{rnd} \ e^{\bnd{\bullet}} \\
(e \{ i \})^{\bnd{\bullet}} &\triangleq e  \\
(\Lambda \epsilon . e)^{\bnd{\bullet}} &\triangleq e \\
% TODO: double check cases and make sure nothing is missing
\end{aligned}
\begin{aligned}[c]
[e]^{\bnd{\bullet}} &\triangleq [e^{\bnd{\bullet}}] \\
(\textbf{factor} \ e)^{\bnd{\bullet}} &\triangleq \textbf{factor} \ e^{\bnd{\bullet}} \\
(\textbf{in}_i \ e)^{\bnd{\bullet}} &\triangleq \textbf{in}_i \ e^{\bnd{\bullet}} \\
(\pi_i \ e)^{\bnd{\bullet}} &\triangleq \pi_i \ e^{\bnd{\bullet}} \\
(\textbf{ret} \ e)^{\bnd{\bullet}} &\triangleq \textbf{ret} \ e^{\bnd{\bullet}} \\
\langle e, f \rangle ^{\bnd{\bullet}} &\triangleq \langle e^{\bnd{\bullet}}, f^{\bnd{\bullet}} \rangle \\
(e, f) ^{\bnd{\bullet}} &\triangleq (e^{\bnd{\bullet}}, f^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
(\textbf{case} \ e \ \textbf{of} \ (\textbf{in}_1 x. f_1 \ | \textbf{in}_2 x. f_2 ))^{\bnd{\bullet}} &\triangleq (\textbf{case} \ e^{\bnd{\bullet}} \ \textbf{of} \ (\textbf{in}_1 x. f_1^{\bnd{\bullet}} \ | \textbf{in}_2 x. f_2^{\bnd{\bullet}} )) \\
(\textbf{let} \ x \ = \ e \ \textbf{in} \ f) ^{\bnd{\bullet}} &\triangleq (\textbf{let} \ x \ = \ e^{\bnd{\bullet}} \ \textbf{in} \ f^{\bnd{\bullet}}) \\
(\textbf{let-bind} \ x \ = \ e \ \textbf{in} \ f) ^{\bnd{\bullet}} &\triangleq (\textbf{let-bind} \ x \ = \ e^{\bnd{\bullet}} \ \textbf{in} \ f^{\bnd{\bullet}}) \\
(\textbf{let-cobind} \ x \ = \ e \ \textbf{in} \ f) ^{\bnd{\bullet}} &\triangleq (\textbf{let-cobind} \ x \ = \ e^{\bnd{\bullet}} \ \textbf{in} \ f^{\bnd{\bullet}}) \\
(\textbf{let-pair} \ (x, y) \ = \ e \ \textbf{in} \ f) ^{\bnd{\bullet}} &\triangleq (\textbf{let-pair} \ (x, y) \ = \ e^{\bnd{\bullet}} \ \textbf{in} \ f^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation*}
\end{definition}

\begin{definition}[Type inference problem]
Given an erased program $e^{\bnd{\bullet}}$, produce a derivation of $. \vdash e
: \tau$ for $e$ in \Lang if such a derivation exists. 
\end{definition}

\subsection{Subtyping for type inference}
Before we provide the algorithm, we extend the subtyping and supertyping
relations used in Numerical Fuzz for type inference. In particular, we add the
following cases to deal with bounds and bound polymoprhism.
$$
\begin{aligned}[c]
  \textbf{num}_{b_0} \sqsubseteq \textbf{num}_{b'_0} &\triangleq b_0 \leq b'_0
  \\
  \textbf{num}_{i} \sqsubseteq \textbf{num}_{i'} &\triangleq \forall i :
  \Delta, \textbf{num}_{i}~[\sigma] \sqsubseteq \textbf{num}_{i'}~[\sigma] \\
  \forall \epsilon_0. \tau \sqsubseteq \forall \epsilon_1. \tau' &\triangleq 
  \forall i : \Delta, \tau~[i/\epsilon_0] \sqsubseteq \tau'~[i/\epsilon_1]
\end{aligned}
$$
the remaining cases are unchanged and listed in Figure~\ref{fig:sub_ty}.
% TODO: consider combining / inlining

\begin{figure}[htbp]
$$
\begin{aligned}[c]
  \textbf{unit} \sqsubseteq \textbf{unit} \\
\end{aligned}
$$

%% ROW1
\begin{center}
%% CART PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\times$}
\BIC{$ \sigma \times \tau \sqsubseteq \sigma' \times \tau' $}
\DisplayProof
\hskip 2.5em
%% TEN PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\tensor$}
\BIC{$ \sigma \tensor \tau \sqsubseteq \sigma' \tensor \tau' $}
\DisplayProof
\hskip 2.5em
%% SUM
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .+$}
\BIC{$ \sigma + \tau \sqsubseteq \sigma' + \tau' $}
\DisplayProof
\vskip 1em

%% FUN
\AXC{$\sigma' \sqsubseteq \sigma$}
\AXC{$\tau \sqsubseteq \tau' $}
\RightLabel{$\sqsubseteq .\multimap$}
\BIC{$ \sigma \multimap \tau \sqsubseteq \sigma' \multimap \tau' $}
\DisplayProof
\hskip 2.5em
%% MONAD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$u \le u'$}
\RightLabel{$\sqsubseteq .$M}
\BIC{$ \text{M}_u \sigma \sqsubseteq \text{M}_{u'} \sigma' $}
\DisplayProof
\hskip 2.5em
%% BANG
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$s \le s'$}
\RightLabel{$\sqsubseteq .!$}
\BIC{$ \bang{s'} \sigma \sqsubseteq !_{s} \sigma' $}
\DisplayProof

\end{center}
    \caption{The remaining cases for the subtype relation in \Lang, with
    $s,s',u,u' \in \NNR \cup \{\infty\}$.}
    \label{fig:sub_ty}
\end{figure}

\begin{theorem}[Admissibility of subtyping] \label{thm:subtyping}
  If $\Delta \ | \ \Gamma \vdash e : \tau$ has a derivation 
  and $\tau' \sqsubseteq \tau'$
  then typing judgement $\Delta \ | \ \Gamma \vdash e : \tau'$ is derivable.
\end{theorem}
\begin{proof}
% TODO: inline NumFuzz proof
  The admissibility of subtyping mostly follows from the proof in
  \cite{numfuzz}.
  We detail the new cases that are not immediate below:
  \begin{description}
    \item[Case (Widen).] Corresponds to the new \textbf{num} cases we added to
      the subtyping relation. 
      % TODO: spell out more
    \item[Case $\forall \epsilon_0 . \tau$.] Follows from application of the
      inductive hypothesis.
      % TODO: spell out more
  \end{description}
  and the new bound widening rule in our type
  system, which corresponds to the $\textbf{num}$ subtyping case. 
  Note that the proof in \cite{numfuzz} relies on
  the admissibility of weakening, which we proved in (Theorem
  \ref{thm:weakening}).
\end{proof}


\subsection{Type inference algorithm}
We are now ready to define the type inference algorithm. Our type inference
algorithm has the following shape:
$$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$$
where we start a program with a typing context $\Gamma^{\bullet}$ that has
erased sensitivity information (but with polymorphic bound variables) and an
erased program $e^{\bnd{\bullet}}$ with no polymorphic bounds, and produces a
typing context $\Gamma$ with sensitivity information and fully annotated program
e and type $\tau$ such that
$\Delta \ | \ \Gamma' \vdash e' : \tau$
is derivable for some $\Delta$ (our soundness criterion). 
Note that we leave the $\Delta$ out of our type inference algorithm and
implicitly reconstruct an appropraite $\Delta$ inside our constructive soundness
proof.

We start type inference by passing the empty context (written ``."), along with
the bound-erased program (written $e^{\bnd{\bullet}}$) to the inference
algorithm detailed in Figure~\ref{fig:inference-algo}. Finally, we evaluate our
bound expressions using the $\llbracket - \rrbracket$ evaluation map defined
over types.
Conceptually, our type inference algorithm does three things: 
\begin{enumerate}
  \item First, we infer sensitivities via the type inference algorithm provided
    in \cite{numfuzz}, extended to deal with our new $\mathbf{factor}$ primitive
    and polymorphic bounds as well as support expressions in greater places.

  \item At the same time as our sensitivity inference, we infer our bounds. We
    rely on helper functions $I$ and $E$
    (Figure~\label{fig:helper_type_inference}) to automatically instantiate and
    eliminate polymorphic bound variables. 

  \item Finally, we evaluate our bound expresions via $\llbracket - \rrbracket$. 
\end{enumerate}
We present our syntax-directed type inference algorithm in
Figure~\ref{fig:inference-algo} as a combined algorithm where the sensitivities
and bounds are inferred simultaneously in one pass.
We prove the soundness of the fused sensitivity-and-bound pass in
Theorem~\ref{thm:algo-soundness} with a syntactic argument inducting over the
inference algorithm. 
After running type inference, we evaluate the closed bound expressions using
$\llbracket - \rrbracket$ and prove soundness via a semantic logical relations
argument.

\begin{figure}\label{fig:inference-algo}
%% ROW1
\begin{center}

\AXC{}
\UIC{$I(\textbf{unit}^{\bnd{\bullet}}) \to \textbf{unit}; .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% \AXC{$\epsilon \not \in FTV(\Gamma) \cup DOM(\Delta)$}
\AXC{$\epsilon \text{ globally fresh}$}
\UIC{$ I(\textbf{num}^{\bnd{\bullet}}) \to \textbf{num}_{\epsilon};
\epsilon $}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \times \tau_1)^{\bnd{\bullet}}) \to \tau_0 \times
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \otimes \tau_1)^{\bnd{\bullet}}) \to \tau_0 \otimes
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 + \tau_1)^{\bnd{\bullet}}) \to \tau_0 + \tau_1; \alpha,
\beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \multimap \tau_1)^{\bnd{\bullet}}) \to \tau_0 \multimap
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau^{\bnd{\bullet}}) \to \tau; \beta$}
\UIC{$I(!_s (\tau^{\bnd{\bullet}})) \to !_s \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau^{\bnd{\bullet}}) \to \tau; \beta$}
\UIC{$I(M_u (\tau^{\bnd{\bullet}})) \to M_u \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\vskip 3em

\AXC{}
\UIC{$E(\textbf{unit}) \to .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{}
\UIC{$E(\textbf{num}_i) \to i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \times \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \otimes \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 + \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \multimap \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau) \to \beta$}
\UIC{$E(!_s (\tau)) \to \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau) \to \beta$}
\UIC{$E(M_u (\tau)) \to \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau) \to \beta$}
\UIC{$E(\forall \epsilon. \tau) \to \beta$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Ancillary functions defining algorithmic type inference. I
    introduces bounds for an type with erased bounds. E extracts the bounds used
  in an unerased type.}
    \label{fig:helper_type_inference}
\end{figure}

\newpage

\begin{figure}
\begin{center}
%% unit
\AXC{}
\RightLabel{(Unit)}
\UIC{$\Gamma^{\bullet}; \langle \rangle^{\bnd{\bullet}}; \implies \Gamma^{0};
\langle \rangle; \textbf{unit}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% var
\AXC{}
\RightLabel{(Var)}
\UIC{$\Gamma^{\bullet}, x : \tau, x^{\bnd{\bullet}} \implies \Gamma^{0}, x
:_1 \tau; x; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%% const
\AXC{}
\RightLabel{(Const)}
\UIC{$\Gamma^{\bullet}; k^{\bnd{\bullet}}; \implies \Gamma^{0};
k; \textbf{num}_{\bnd{inj(k)}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% bang intro
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{($!$ I)}
\UIC{$\Gamma^{\bullet}; [e]_{\annotate{s}}^{\bnd{\bullet}} \implies \annotate{s}
* \Gamma'; [e']_{\annotate{s}}; !_s~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% fun
\AXC{$I(\tau_0^{\bnd{\bullet}}) = \annotate{\tau_0}; \epsilon_0, \ldots, \epsilon_n$}
\AXC{$\Gamma^{\bullet}, x : \annotate{\tau_0}; e^{\bnd{\bullet}} \implies \Gamma', x
:_s \annotate{\tau_0}; e'; \tau$}
\AXC{$s \geq 1$}
\RightLabel{($\multimap$ I)}
\TIC{$\Gamma^{\bullet}; \lambda (x : \annotate{\tau_0^{\bnd{\bullet}}}). e^{\bnd{\bullet}}
\implies \Gamma'; \Lambda \epsilon_0, \ldots, \epsilon_n
(\lambda (x : \annotate{\tau_0}) . e'); \forall \epsilon_0, \ldots, \epsilon_n . \
\annotate{\tau_0} \multimap \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% imp elim, forall
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}; f^{\bnd{\bullet}} &\implies \Gamma'; f'; \forall
\epsilon_0, \ldots, \epsilon_n \ . \ \tau_0 \multimap \tau \\
\Gamma^{\bullet}; e^{\bnd{\bullet}} &\implies \Theta; e'; \tau'_0 \\
\end{aligned} $}
\hskip 0.5em
\AXC{$\begin{aligned}[t]
E(\tau'_0) &= i_0, \ldots, i_n \\
\tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] &\sqsubseteq \tau'_0 \\
\end{aligned}
$}
\RightLabel{($\multimap$ E)}
\BIC{$\Gamma^{\bullet}; (f~e)^{\bnd{\bullet}} \implies \Gamma' +
\Theta; (f'~\{ i_0 \}~\ldots~\{ i_n \})~e'; \tau[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$}
\bottomAlignProof
\DisplayProof
\vskip 1em
% todo: evaluating the liftted iops happen after we complete inference

% todo: require that ops are closed at the bound polymorphism level
\RightLabel{(\textbf{op})}
\AXC{$\{\textbf{op} : \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1 \} \in \Sigma$}
\UIC{$\Gamma^{\bullet}; \textbf{op}^{\bnd{\bullet}} \implies \Gamma;
\textbf{op}; \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{factor})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; (M_q
\tau_0 \times M_r \tau_1)$}
\UIC{$\Gamma^{\bullet}; \textbf{factor}~e^{\bnd{\bullet}} \implies
\Gamma'; \textbf{factor}~e'; M_{max(q, r)} (\tau_0 \times \tau_1)$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Structural rules below                            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 1em

%% Ret
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Ret})}
\UIC{$\Gamma^{\bullet}; \textbf{ret}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{ret}~e'; M_0~\tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% Rnd
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Rnd})}
\UIC{$\Gamma^{\bullet}; \textbf{rnd}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{rnd}~e'; M_q~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% times intro 
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_0; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_1; f'; \tau_1$}
\RightLabel{($\times$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}} \implies
\text{max}(\Gamma_0, \Gamma_1); \langle f', e' \rangle; \tau_0 \times \tau_1$}
% todo: check that max is defined
\bottomAlignProof
\DisplayProof
\RightLabel{($\times$ E)}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0
\times \tau_1$}
\UIC{$\Gamma^{\bullet}; (\pi_i~e)^{\bnd{\bullet}} \implies
\Gamma'; \pi_i~e'; \tau_i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% otimes intro 
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_0; f'; \tau_1$}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_1; e'; \tau_0$}
\RightLabel{($\otimes$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}}
\implies \Gamma_0 + \Gamma_1; (f', e'); \tau_0 \otimes \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}, x : \tau_0; f^{\bnd{\bullet}} \implies \Theta, x :_s
\tau_0; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma + \Theta;
\textbf{let} \ x \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-pair})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
\tau_0 \otimes \tau_1$}
\AXC{$\Gamma^{\bullet}, x: \tau_0, y : \tau_1; f^{\bnd{\bullet}}
\implies \Theta, x :_s \tau_0, y :_{s'} \tau_1; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-pair} \ (x, y) \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies max(s, s') \cdot \Gamma' + \Theta;
\textbf{let-pair} \ (x, y) \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-bind})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
M_r~\tau_0$}
\AXC{$\Gamma^{\bullet}, x: \tau_0; f^{\bnd{\bullet}} \implies \Theta, x
:_s \tau_0; f; M_q~\tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-bind} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma' + \Theta;
\textbf{let-bind} \ x \ = \ e' \ \textbf{in} \ f'; M_{s \cdot r + q}~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{case})}
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma; e'; \tau_0 + \tau_1 \\
s > 0
\end{aligned}
$}
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}, x : \tau_0 ; f_1^{\bnd{\bullet}} \implies \Theta_0, x :_s \tau_0; f'_1; \tau_0 \\
\Gamma^{\bullet}, x : \tau_0 ; f_2^{\bnd{\bullet}} \implies \Theta_1, x :_s \tau_0; f'_2; \tau_1
\end{aligned}
$}
\BIC{$\Gamma^{\bullet}; (\textbf{case} \ e \ \textbf{of} \
(\textbf{in}_1~x.f_1 ~ | ~ \textbf{in}_2~x.f_2))^{\bnd{\bullet}}
\implies s \cdot \Gamma + max(\Theta_0, \Theta_1); (\textbf{case} \ e' \ \textbf{of}
\ (\textbf{in}_1~x.f'_1 ~ | ~ \textbf{in}_2~x.f'_2)) ; \text{max}(\tau_0, \tau_1)$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Algorithmic rules. \annotate{Red text} are user-required
    annotations. To help define the $\implies$ relation, we
    define a $\to$ relation that annotates (removes the bullet) for a given
    type.}
    \label{fig:type_inference}
\end{figure}


\begin{lemma}[Free vars in $\Gamma$.] \label{thm:free-var-gamma}
  For any typing derivation for some $\Delta \ | \ \Gamma \vdash e : \tau$,
  $FTV(\Gamma) \subseteq \Delta$ and $FTV(\tau) \subseteq \Delta$.
\end{lemma}
\begin{proof}
  By induction over the $\vdash$ relation.
\end{proof}

\begin{lemma}[Free vars in I.] \label{thm:free-var-i}
  For any type $\tau$, $I(\tau) = \tau'; \epsilon_0 \ldots \epsilon_n$, we have
  that $FTV(\tau') = \{ \epsilon_0, \ldots, \epsilon_n \}$.
\end{lemma}
\begin{proof}
  By induction over the definition of $I$.
\end{proof}

\begin{lemma}[Well-formedness of bounds produced by $E$.] \label{thm:wff-var-e}
  For any types $\tau$, $E(\tau) \to i_0, \ldots, i_n$ means that for every
  $i_j$, if $FTV(\tau) \subseteq \Delta$ then $\Delta \vdash i_j$.
\end{lemma}
\begin{proof}
  We apply weakening (over bound contexts, Lemma~\ref{thm:weakening-bnd}) to the
  conclusion. So it suffices to prove that $FTV(\tau) \vdash i_j$. We complete
  the proof by induction over $\tau$.
\end{proof}

Now we are able to prove the soundness of our type inference algorithm. Note
that if the ordering of the variables produced by the I and E helper functions
do not align, the subtyping check in the $\multimap$ E case will fail. This
means that the choice of ordering is not essential for our soundness proof but
would be relevant for a completeness argument.

Note that we have that $\Gamma^{\bullet} = \Gamma'^{\bullet}$ and
$e^{\bnd{\bullet}} = e'^{\bnd{\bullet}}$ as we do not prove that our type
inferencde algorithm infers the tightest possible sensitivity or round-off
grades.
% TODO: prove that we infer the tighest possible sens + round-off error grades
% (or provide counterexample).
\begin{theorem}[Algorithmic Soundness] \label{thm:algo-soundness}
If $\Gamma^{\bullet}; e^{\bullet} \implies \Gamma'; e'; \tau$ then there is
some $\Delta$ such that $\Delta \ | \ \Gamma' \vdash e' : \tau$ has a typing
derivation where $\Gamma^{\bullet} = \Gamma'^{\bullet}$ and $e^{\bnd{\bullet}} =
e'^{\bnd{\bullet}}$.
\end{theorem}
\begin{proof}
We induct over each typing / case in the type inference algorithm. 
\begin{description}
  \item[$\textbf{unit}$.] Holds trivially.
  \item[Var.] Holds trivially.
  \item[Const.] Holds trivially. 
  % TODO: spell out delta
  \item[! I.] Holds trivially. Note that our sensitivity scaling factor
    $\annotate{s}$ is user-annotated.
  \item[$\multimap$ I.] By our inductive hypothesis, we know that there exists a
    $\Delta'$ such that we have a typing derivation $d$ for 
    $\Delta' \ | \ \Gamma', x:_s \tau_0 \vdash e' : \tau$. 
    We wish for each $\epsilon_0, \ldots , \epsilon_n$ to apply our
    $\forall$ I rule to $d$. 
    \par\bigskip
    For each application of our $\forall$ I rule using variable $\epsilon_i$, we
    must satisfy that:
    (1) $\epsilon_i \in \Delta'$ and (2) $\epsilon_i \not\in FTV(\Gamma)$.

    Let $\Delta = FTV(\tau_0) = \{\epsilon_0, \ldots, \epsilon_n\}$ by
    Lemma~\ref{thm:free-var-i}. 
    Then, we have that $\Delta \subseteq \Delta'$ by
    Lemma~\ref{thm:free-var-gamma} and therefore each $\epsilon_0, \ldots,
    \epsilon_n \not\in \Delta'$.
    We further have that $FTV(\Gamma) \cap \Delta = \emptyset$ as $I$ only
    generates fresh vars. 
    So both of our two conditions have been satisifed for all $\epsilon_i$.
  \item[$\multimap$ E.] By our inductive hypothesis, we know that there exist
    derivations:
    \begin{itemize}
      \item $d_0$ where $\Delta' \ | \ \Gamma' \vdash f : \forall
        \epsilon_0, \ldots, \epsilon_n, \tau_0 \multimap \tau$
      \item $d_1$ where $\Delta'' \ | \ \Theta \vdash e : \tau_0'$
    \end{itemize}
    Note that $\epsilon_0, \ldots, \epsilon_n$ are fresh from $\Delta''$ as each
    $\epsilon$ generated is globally fresh in our type inference algorithm.
    \par\bigskip
  % TODO: spell out delta

    By weakening on our inductive hypothesis, we have a derivation for $\Delta \
    | \ \Theta \vdash e : \tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$.
    Then we are able to iteratively apply the $\forall \text{ E}$ typing rule to
    our derivation $d_0$ for each
    $\epsilon_0, \ldots, \epsilon_n$, obtaining
    us the following intermediate typing derivation $d_3$: 
    $\Delta' - \{\epsilon_0, \ldots, \epsilon_n\} \cup \Delta'' \ | \ \Gamma'
    \vdash f' \ \{i_0\} \ldots \{i_n\} : 
    (\tau_0 \multimap \tau) [\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$ 
    whose type is the same as the following
    $\tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] \multimap \tau[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$.
    \par\bigskip

    Note that the $\Delta \vdash i : \textbf{bnd}$ condition in each application
    of the $\forall E$ rule is satisfied by applying Lemma~\ref{thm:wff-var-e}
    and Lemma~\ref{thm:free-var-gamma} on the polymorphic bound judgements.
    In particular, by Lemma~\ref{thm:free-var-gamma}, we have that
    $FTV(\tau'_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]) \subseteq FTV(\tau'_0)
    \subseteq FTV(\Theta) \subseteq \Delta''$. 
    Applying Lemma~\ref{thm:wff-var-e} and our inductive hypothesis finishes
    each proof obligation.
    Now we are ready to apply our $\multimap E$ typing rule with derivation
    $d_1$ to obtain a dervation for: $\Delta' \cup \Delta'' \vdash (f' \ \{i_0\}
    \ldots \{i_n\}) e' : \tau[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$ which completes the case.
  \item[Op.] Holds trivially.
  \item[Factor.] Holds trivially.
  \item[Ret.] Holds trivially.
  \item[Rnd.] Holds trivially.
  \item[$\times$ I.] Like Numerical Fuzz, we define \text{max} as the least
    upper bound of $\Gamma_0$ and $\Gamma_1$. Let $\Delta_0$ and $\Delta_1$ be
    the (implicit) polymorphic bound contexts generated by our inductive
    hypothesis.
    By weakening, we can produce a typing derivation for the following
    judgement:
    $\Delta_0 \cup \Delta_1 \ | \ \text{max}(\Gamma_0, \Gamma_1) \vdash \langle
    f', e' \rangle; \tau_0 \times \tau_1$ which completes the case.
  \item[$\times$ E.] Holds trivially.
  \item[$\otimes$ I.] Holds trivially.
  \item[Let.] Holds trivially.
  \item[Let-pair.] Holds by applying weakening to the second inductive
    hypothesis to obtain a derivation $\Delta \ | \ \Gamma, x :_{\text{max}(s,
    s')} \tau_0, y :_{\text{max}(s, s')} \tau_1 \vdash f' : \tau$ and applying
    the corresponding $\otimes \text{ E}$ rule to complete the case.
  \item[Let-bind.] Holds trivially.
  \item[$\otimes$ E.] By the definition of $\text{max}$, we have that 
    $\tau_0 \subseteq \text{max}(\tau_0, \tau_1)$
    and
    $\tau_1 \subseteq \text{max}(\tau_0, \tau_1)$.
    
    Applying the admissibility of subtyping (Theorem~\label{ref}) to our inductive
    hypothesis, we obtain: 
    $\Delta_0 \ | \ \Theta_0 x :_s \tau_0 \vdash f'_1 : \text{max}(\tau_0, \tau_1)$
    and
    $\Delta_1 \ | \ \Theta_1 x :_s \tau_1 \vdash f'_2 : \text{max}(\tau_0, \tau_1)$.
    We can now finish by applying our $\otimes$ E typing rule which completes
    the case.
\end{description}
\end{proof}

After running type inference we obtain a result in the form: 
$\Delta \ | \ \Gamma \vdash e : \tau$. 
In some cases, $\tau$ might contain bound expressions.
For example, after running type inference on the program $add \langle 1, 2 \rangle$, we might
obtain the following type 
$. \vdash \textbf{add} \ \langle 1, 2 \rangle : M_u \ \textbf{num}_{(1, 1, 0, \text{True}) + (2, 2, 0, \text{True})}$
Semantically, this type represents the same relation as:
$. \vdash \textbf{add} \ \langle 1, 2 \rangle : M_u \ \textbf{num}_{(3, 3, 0, \text{True})}$

To handle such cases, we extend the $\bnd{\llbracket - \rrbracket}$
(Definition~\ref{def:interval-exp-eval}) evaluating bound expressions to also
evaluate types that possibly contain bound expressions. Importantly our
soundness theorem proved below, the logical relation corresponding to the
evalauted type should be the same logical relation as the original type. This is
a semantic notion of soundness, which is why we present the evaluation of types
and bound expressions separately from our syntax-directed type inference
algorithm.

\begin{definition}[Type evaluation]
Our type evaluation scheme $\llbracket - \rrbracket$ takes in a type $\tau$ and
spits out a type $\tau'$:
\begin{equation}
  \begin{aligned}[c]
    \llbracket \textbf{unit} \rrbracket &= \textbf{unit} \\
    \llbracket \textbf{num}_{\bnd{b}} \rrbracket &= \textbf{num}_{\bnd{\llbracket b \rrbracket}} \\
    \llbracket \tau_0 \times \tau_1 \rrbracket &= \llbracket \tau_0 \rrbracket
      \times \llbracket \tau_1 \rrbracket \\
    \llbracket \tau_0 \otimes \tau_1 \rrbracket &= \llbracket \tau_0 \rrbracket
      \otimes \llbracket \tau_1 \rrbracket \\
    \llbracket \tau_0 + \tau_1 \rrbracket &= \llbracket \tau_0 \rrbracket
      + \llbracket \tau_1 \rrbracket \\
    \llbracket \tau_0 \multimap \tau_1 \rrbracket &= \llbracket \tau_0 \rrbracket
      \multimap \llbracket \tau_1 \rrbracket \\
    \llbracket !_s \tau \rrbracket &= !_s \llbracket \tau \rrbracket \\
    \llbracket M_u \tau \rrbracket &= M_u \llbracket \tau \rrbracket \\
    \llbracket \forall \epsilon . \tau \rrbracket &= \forall \epsilon . \tau
  \end{aligned}
\end{equation}
Note that for simplicity, we only halt evaluation when we see a $\forall$. 
\end{definition}

\begin{theorem}[Soundness of evaluating closed bounds]
  For any $e \in \mathbb{R}_{\tau}$ and $\tau' = \llbracket \tau \rrbracket$,
  then $e \in \mathbb{R}_{\tau'}$.
\end{theorem} 
\begin{proof}
  We induct over the definition of $\llbracket - \rrbracket$ to show that
  $\mathbb{R}_\tau = \mathbb{R}_{\tau'}$ at each step.
  The structural cases are immediate.
  The only non-structural case evaluates $\textbf{num}_{\bnd{b}}$ to
  $\textbf{num}_{\llbracket \bnd{b} \rrbracket}$. Since $\bnd{b \sim \llbracket b
  \rrbracket}$, they are in the same equivalence class and thus the same logical
  relation.
\end{proof}

\subsection{Example programs and types}
We now demonstrate to run set up and run the type inference problem from start
to finish on an example FPCore benchmark.
We also remark on several observations that match our intuition on how the
algorithm behaves.

% TODO: add tightness by example argument

% \subsection{Tightness} \label{sec:tightness}
% A natural question to ask is whether the paired representation introduced in the
% proceeding section leads to looser error bounds on programs that could have been
% typed using the standard, unpaired representation. In the following section, we
% demonstrate that for the programs obtained using the unpaired representation in
% Numerical Fuzz, our bounds inferred through type inference and obtained through
% our paired representation are no looser.
%
% To demonstrate this, we instantiate our language with the following interface
% $(\mathbb{P}^{+}, d, \rho_{\mathbb{P}}, u, \Sigma = \{ \mathbf{add},
% \mathbf{mul} \}, \Sigma_{\mathbf{num}})$, where 
% $\mathbb{P}^+ = \{(r, r, 0) \ | \ \forall r \in \mathbb{R}^{+} \}$ 
% and 
% $d((r, a, b), (r', a', b')) = d_{\mathbb{R}}(r, r')$.
% Note that we do not modify our modular type inference algorithm and leave the
% instantiation the same.
% Let us write programs derivable in this type system using the
% $\vdash_{\mathbb{R}}$ judgement and $\vdash_{\mathbb{P}}$ for the
% paired representation instantiated previously. % todo: add backref
% We observe that programs step the same in both instantiations of the language
% and also that programs derivable in $\vdash_{\mathbb{R}}$ have the same type
% with $\vdash_{\mathbb{P}}$:
% \begin{lemma}[Derivablity]
% If $\Delta \ | \ \Gamma \vdash_{\mathbb{R}} e : \tau$,
% then
% $\Delta \ | \ \Gamma \vdash_{\mathbb{P}} e : \tau$ 
% \end{lemma}
% \begin{proof}
%   Proof by induction. $\vdash_{\mathbb{R}}$ has strictly less operations and the
%   associated rounding functions $\rho_{\mathbb{P}}$ and $u$ bounds are the same.
% \end{proof}
%
% We also observe that for a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, $q$ suffices to bound the
% maximum permitted round-off error.
%
% \begin{theorem}[Unpaired error soundness theorem]
% For a program $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we have that $ e \mapsto^{*} ((r, a,
% b), (r', a', b'))$ where $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Holds by applying our metric preservation theorem and unfolding our logical
%   relation and error metric.
% \end{proof}
%
% We are now ready to state our tightness theorem which guarantees that the paired
% representation produced error bounds no looser than the unpaired representation.
%
% \begin{lemma}[Tightness type inference lemma]\label{thm:tightness-helper}
%   If $b$ is always zero in our concrete domain and our program does not contain
%   subtraction, our type inference algorithm always infers that $b^{\uparrow} =
%   b^{\downarrow} = 0$.
% \end{lemma}
% \begin{proof}
%   We track all the intervals produced by the type inference algorithm. Intervals
%   are produced by $inj$ (base case) or by applying our lifted operations $op^{\#}$ (inductive case).
%   By induction, in both cases, our invariant $b^{\uparrow} = b^{\downarrow} =
%   0$ holds.
% \end{proof}
%
% \begin{theorem}[Tightness]
% For a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we know that $. \vdash e
% :  M_q \mathbf{num}_i$ and $e \mapsto^{*} ((r, a, b), (r', a', b'))$ where 
% $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Unfold our logical relation and error metric. Note that our underlying carrier
%   set of $\mathbb{P}$ is zeroed out in the last component. By
%   Lemma~\ref{thm:tightness-helper}, we know that our type inference algorithm
%   will produce $b = b^{\uparrow} = b^{\downarrow} = 0$. 
%   By applying our a priori error theorem
%   (Theorem~\ref{thm:paired-a-priori-rel}), we have our terms neatly zero out and
%   simplify such that $d_{\mathbb{R}}(r, r') = ln(e^q) = q$.
% \end{proof}

% TODO: clarify how to start / use interval analysis, stitch together theorems
