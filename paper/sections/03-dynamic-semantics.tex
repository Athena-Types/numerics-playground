\section{Dynamic Semantics}

\subsection{Substitution-style Operational Semantics}
The following is defined over untyped terms. In particular, we define the
operational semantics rewrite relation $\mapsto$ to map from (untyped) \Lang
to (untyped) \Lang. In other words, untypable programs can step (but not
necessarily to values).

\begin{figure}
\begin{center}

\begin{equation*}
\begin{aligned}[c]
	\mathbf{op}(v) &\mapsto op(v)\\
	\pi_i\langle v_1,v_2 \rangle &\mapsto v_i \\
	(\lambda x.e) \ v &\mapsto e[v/x] \\
	%\factor v \ &\mapsto v
\end{aligned}
\quad
\begin{aligned}[c]
	\letassign x = v \ \tin \ e &\mapsto e[v/x] \\
  \letpair (x, y) = (v, w) \ \tin \ e &\mapsto e[v/x][w/y] \\
	\letcobind x = v \ \tin \ e &\mapsto e[v/x]
	%\letbind x = \ret v \ \tin \ e &\mapsto e[v/x] \\
\end{aligned}
\end{equation*}
\vskip -1em
\begin{align*}
  \letbind y = (\letbind x = v \ \tin \ f) \ \tin \ g &\mapsto \letbind x = v \ \tin \ \letbind y = f \ \tin \ g \quad x\notin FV(g) 
\end{align*}
\vskip -1.75em
\begin{align*}
	\mathbf{case} \ (\mathbf{in}_i \ v) \ \mathbf{of} \ (\mathbf{in}_1 \ x.e_1 \ | \ \mathbf{in}_2 \ x.e_2 )  &\mapsto e_i[v/x]
  \qquad\qquad(i \in \{1, 2 \})
\end{align*}
\vskip -0.25em

	\AXC{$e \mapsto e'$}
	\UIC{$\letassign x = e \ \tin \ f \mapsto \letassign x = e' \ \tin f$}
	\DisplayProof

\end{center}
    \caption{Substitution-style evaluation rules for \Lang. Note the side condition for $\letbind$always holds for closed expressions.}
    \label{fig:sub_eval_rules}
\end{figure}

\subsection{(Typed) Enviroment-style Operational Semantics}
The following is defined over typed terms. In particular, we define the
operational semantics rewrite relation $\rightsquigarrow$ to map from a typed
term in an program enviroment to a typed term in an program enviroment. Note
that in this setup, $\letbind x = v \ \tin \ f$ and $[x]$ are \textit{not}
values.

To be precise, $\rightsquigarrow$ maps an expression $e$ with type $\tau$
running in an enviroment $\sigma$ mapping variables like $x_1$ to value $v_1$
with type $\tau_1$ and sensitivity budget $s_1$ to a $e'$ with type $\tau'$ and
enviroment $\sigma'$.
So, $\sigma$ send variables like $x_1 \to v_1 :_s \tau_1$.

An enviroment $\sigma$ is compatible with a typing context $\Gamma$ if
$\llbracket \sigma \rrbracket$ is a point within metric space $\llbracket \Gamma
\rrbracket$ (after erasing $\sigma$'s $0$-sensitive variables). Abusing notation
a little, I write this like so: $\llbracket \sigma \rrbracket \in \llbracket
\Gamma \rrbracket$.

\begin{equation*}
  \llbracket \sigma \rrbracket \in \llbracket \Gamma \rrbracket 
  \triangleq \forall
  \\ 
  (x \mapsto v :_s \tau) \in \sigma, 0 < s \implies (x :_s \tau) \in \llbracket
  \Gamma \rrbracket
\end{equation*}

Similarly, $\llbracket \sigma \Vdash e : \tau \rrbracket$ is
interpreted as the point in the metric space $\llbracket \tau \rrbracket$
obtained by running e at $\sigma$.

Useful adequacy-flavored theorem to prove. If $\sigma \Vdash e : \tau \rightsquigarrow \sigma'
\Vdash e' : \tau'$, then $\llbracket \sigma \Vdash e : \tau \rrbracket =
\llbracket \sigma' \Vdash e' : \tau' \rrbracket$.

Another adequacy-flavored theorem (in reverse). If $\llbracket \sigma \Vdash e :
\tau \rrbracket = \llbracket \sigma' \Vdash v : \tau' \rrbracket$, then $\sigma
\Vdash e : \tau \rightsquigarrow^{*} \sigma' \Vdash v : \tau'$

A syntatic type-soundness flavored theorem. If $\Gamma \vdash e : \tau$, then
$\forall \llbracket \sigma \rrbracket \in \llbracket \Gamma \rrbracket, \exists
\sigma' \ v \ \tau', \sigma \Vdash e : \tau \rightsquigarrow^{*} \sigma' \Vdash v :
\tau'$ and $\llbracket \tau \rrbracket = \llbracket \tau' \rrbracket$.

An error-soundness flavored theorem. For $\llbracket \Gamma \vdash e : \tau
\rrbracket$ and $\sigma, \sigma' \in \Gamma$ and
$$\sigma \Vdash e : \tau \rightsquigarrow^* \sigma_{empty} \Vdash v : \tau'$$ 
and 
$$\sigma' \Vdash e : \tau \rightsquigarrow^* \sigma_{empty'} \Vdash v' : \tau''$$
%the distance between $\llbracket \sigma \rrbracket$ and $\llbracket \sigma'
%\rrbracket$ in metric space $\llbracket \Gamma \rrbracket$ is greater than or
%equal to the distance between $\llbracket \sigma \Vdash e : \tau \rrbracket$ and
%$\llbracket \sigma' \Vdash e : \tau \rrbracket$. In other words,
then
$$
d_{\llbracket \tau \rrbracket}(v, v') \leq d_{\llbracket \Gamma \rrbracket}(\sigma, \sigma')
$$
where $\sigma_{empty}, \sigma_{empty'}$ means
$$
\forall (x \mapsto v :_s \tau) \in \sigma_{empty}, \sigma_{empty'}, s = 0
$$

Note that $\sigma$ is ordered in the case that variables are shadowed. $\sigma[x
\mapsto v :_s \tau]$ denotes lookup (when on the left-hand side of a rewrite
relation) or insertion from the right (when on the right-hand side of a rewrite
relation).

\begin{figure}
\begin{center}
\begin{equation*}
  \begin{aligned}[c]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % more spicy rules
    % THE important rule for an enviroment-style semantics: lookup!
    \sigma[x \mapsto v :_s \tau] \Vdash \ x \ : \tau &\rightsquigarrow 
    \sigma \Vdash v : \tau \\
    % let-bind rule
    \sigma \Vdash \textbf{let-bind}_{(s, \tau_1)} \ x = v \ : M_{q} \tau \ \tin \ f &\rightsquigarrow \sigma[x
    \mapsto v :_s \tau_1]
    \Vdash f : M_q \tau \\
    % let-cobind rule
    \sigma \Vdash \textbf{let-cobind}_{(s, t, \tau_1)} \ x = v \ : \tau \ \tin \ f &\rightsquigarrow (\sigma[x
    \mapsto v :_s \tau_1]) * t
    \Vdash f : \tau \\
    % [e] rule
    \sigma \Vdash [e]_s \ : \ \tau &\rightsquigarrow \sigma * s \Vdash e \ : \ \tau \\
    % lam app
    \sigma \Vdash (\lambda x : \tau_1 .e) \ v : \tau &\rightsquigarrow \sigma[x
    \mapsto v :_1 \tau_1] \Vdash e : \tau \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % more boring rules
    % op(v) rule
    \sigma \Vdash \mathbf{op}(v) : \tau &\rightsquigarrow \sigma \Vdash op(v) :
    \tau \\
    % proj rule
    \sigma \Vdash \pi_i\langle v_1,v_2 \rangle : \tau &\rightsquigarrow \sigma
    \Vdash v_i : \tau \\ 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \end{aligned}
\end{equation*}
	%
	%\AXC{$e \mapsto e'$}
	% \UIC{$\sigma \Vdash [e] : !_s \tau \rightsquigarrow \sigma * s \Vdash e : \tau$}
	%\DisplayProof

\end{center}
    \caption{Enviroment-style evaluation rules for \Lang. Note that during type
    checking but prior to running the operational semanitcs, the sensitivity
    information (tracked with metavar $s$) and type of bound variables $\tau_1,
    \tau_2$, is preserved as annotations in the syntax, written $[e]_s$ and
    $\textbf{let-bind}_{(s, \tau_1)}$, $\textbf{let-cobind}_{(s, t, \tau_1)}$,
    and $\lambda x : \tau_1 . e $.}
    \label{fig:sub_eval_rules}
\end{figure}
