\section{Dynamic Semantics}

\subsection{Substitution-style Operational Semantics}
The following is defined over untyped terms. In particular, we define the
operational semantics rewrite relation $\mapsto$ to map from (untyped) \Lang
to (untyped) \Lang. In other words, untypable programs can step (but not
necessarily to values).

\begin{figure}
\begin{center}

\begin{equation*}
\begin{aligned}[c]
	\mathbf{op}(v) &\mapsto op(v)\\
	\pi_i\langle v_1,v_2 \rangle &\mapsto v_i \\
	(\lambda x.e) \ v &\mapsto e[v/x] \\
	%\factor v \ &\mapsto v
\end{aligned}
\quad
\begin{aligned}[c]
	\letassign x = v \ \tin \ e &\mapsto e[v/x] \\
  \letpair (x, y) = (v, w) \ \tin \ e &\mapsto e[v/x][w/y] \\
	\letcobind x = v \ \tin \ e &\mapsto e[v/x]
	%\letbind x = \ret v \ \tin \ e &\mapsto e[v/x] \\
\end{aligned}
\end{equation*}
\vskip -1em
\begin{align*}
  \letbind y = (\letbind x = v \ \tin \ f) \ \tin \ g &\mapsto \letbind x = v \ \tin \ \letbind y = f \ \tin \ g \quad x\notin FV(g) 
\end{align*}
\vskip -1.75em
\begin{align*}
	\mathbf{case} \ (\mathbf{in}_i \ v) \ \mathbf{of} \ (\mathbf{in}_1 \ x.e_1 \ | \ \mathbf{in}_2 \ x.e_2 )  &\mapsto e_i[v/x]
  \qquad\qquad(i \in \{1, 2 \})
\end{align*}
\vskip -0.25em

	\AXC{$e \mapsto e'$}
	\UIC{$\letassign x = e \ \tin \ f \mapsto \letassign x = e' \ \tin f$}
	\DisplayProof

  \vskip 0.4em
	\AXC{$e_1 \mapsto e_1'$}
	\AXC{$e_2 \mapsto e_2'$}
  \BIC{$(e_1, e_2) \mapsto (e_1', e_2')$}
	\DisplayProof

  \vskip 0.4em
	\AXC{$e_1 \mapsto e_1'$}
	\AXC{$e_2 \mapsto e_2'$}
  \BIC{$\langle e_1, e_2 \rangle \mapsto \langle e_1', e_2' \rangle$}
	\DisplayProof
\end{center}
    \caption{Substitution-style evaluation rules for \Lang. Note the side condition for $\letbind$always holds for closed expressions.}
    \label{fig:sub_eval_rules}
\end{figure}

\subsection{(Typed) Enviroment-style Operational Semantics}
The following is defined over typed terms. In particular, we define the
operational semantics rewrite relation $\rightsquigarrow$ to map from a typed
term in an program enviroment to a typed term in an program enviroment. Note
that in this setup, $\letbind x = v \ \tin \ f$ and $[x]$ are \textit{not}
values.

To be precise, $\rightsquigarrow$ maps an expression $e$ with type $\tau$
running in an enviroment $\sigma$ mapping variables like $x_1$ to value $v_1$
with type $\tau_1$ and sensitivity budget $s_1$ to a $e'$ with type $\tau'$ and
enviroment $\sigma'$.
So, $\sigma$ send variables like $x_1 \to v_1 :_s \tau_1$.

An enviroment $\sigma$ is compatible with a typing context $\Gamma$ if
$\llbracket \sigma \rrbracket$ is a point within metric space $\llbracket \Gamma
\rrbracket$ (after erasing $\sigma$'s $0$-sensitive variables). Abusing notation
a little, I write this like so: $\llbracket \sigma \rrbracket \in \llbracket
\Gamma \rrbracket$.
% spell out definiion more

% \begin{equation*}
%   \llbracket \sigma \rrbracket \in \llbracket \Gamma \rrbracket 
%   \triangleq \forall
%   \\ 
%   (x \mapsto v :_s \tau) \in \sigma, 0 < s \implies (x :_s \tau) \in 
%   \Gamma
% \end{equation*}

% spell out definiion more
Similarly, $\llbracket \sigma \Vdash e : \tau \rrbracket$ is
interpreted as the point in the metric space $\llbracket \tau \rrbracket$
obtained by running e at $\sigma$.

Useful adequacy-flavored theorem to prove. If $\sigma \Vdash e : \tau \rightsquigarrow \sigma'
\Vdash e' : \tau$, then $\llbracket \sigma \Vdash e : \tau \rrbracket =
\llbracket \sigma' \Vdash e' : \tau \rrbracket$.

Another adequacy-flavored theorem (in reverse). If $\llbracket \sigma \Vdash e :
\tau \rrbracket = \llbracket \sigma_{empty} \Vdash v : \tau \rrbracket$, then $\sigma
\Vdash e : \tau \rightsquigarrow^{*} \sigma_{empty} \Vdash v : \tau$

A syntatic type-soundness flavored theorem. If $\Gamma \vdash e : \tau$, then
$\forall \llbracket \sigma \rrbracket \in \llbracket \Gamma \rrbracket, \exists
\sigma' \ v \ \tau', \sigma \Vdash e : \tau \rightsquigarrow^{*} \sigma' \Vdash v :
\tau'$ and $\llbracket \tau \rrbracket = \llbracket \tau' \rrbracket$.

Another flavored soundness theorem. For $\llbracket \Gamma \vdash e : \tau
\rrbracket$ and $\sigma, \sigma' \in \Gamma$ and
$$\sigma \Vdash e : \tau \rightsquigarrow^* \sigma_{empty} \Vdash v : \tau'$$ 
and 
$$\sigma' \Vdash e : \tau \rightsquigarrow^* \sigma_{empty'} \Vdash v' : \tau''$$
%the distance between $\llbracket \sigma \rrbracket$ and $\llbracket \sigma'
%\rrbracket$ in metric space $\llbracket \Gamma \rrbracket$ is greater than or
%equal to the distance between $\llbracket \sigma \Vdash e : \tau \rrbracket$ and
%$\llbracket \sigma' \Vdash e : \tau \rrbracket$. In other words,
then
$$
d_{\llbracket \tau \rrbracket}(v, v') \leq d_{\llbracket \Gamma \rrbracket}(\sigma, \sigma')
$$
where $\sigma_{empty}, \sigma_{empty'}$ means
$$
\forall (x \mapsto v :_s \tau) \in \sigma_{empty}, \sigma_{empty'}, s = 0
$$

Note that $\sigma$ is ordered in the case that variables are shadowed. $\sigma[x
\mapsto v :_s \tau]$ denotes lookup (when on the left-hand side of a rewrite
relation) or insertion from the right (when on the right-hand side of a rewrite
relation).

\begin{figure}
\begin{center}
\begin{equation*}
  \begin{aligned}[c]
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % more spicy rules
    % Lookup (sensitivity budget 1)
    \sigma[x \mapsto v :_1 \tau] \Vdash \ x \ : \tau &\rightsquigarrow 
    \sigma \Vdash v : \tau \\
    % Lookup (sensitivity budget greater than 1)
    \sigma[x \mapsto v :_{s} \tau] \Vdash \ x \ : \tau &\rightsquigarrow
    \sigma[x \mapsto v :_{s-1} \tau] \Vdash v : \tau \quad{(\text{with } 1 < s)}
    \\
    % let-bind rule
    % \sigma \Vdash \textbf{let-bind}_{(s, \tau_1)} \ x = v \ : M_{q} \tau \ \tin \ f &\rightsquigarrow \sigma[x
    % \mapsto v :_s \tau_1]
    % \Vdash f : M_q \tau \\
    % let-cobind rule
    % \sigma \Vdash \textbf{let-cobind}_{(s, t, \tau_1)} \ x = v \ : \tau \ \tin \ f &\rightsquigarrow (\sigma[x
    % \mapsto v :_s \tau_1]) * t
    % \Vdash f : \tau \\
    % [e] rule
    % \sigma \Vdash [e]_s \ : \ \tau &\rightsquigarrow \sigma * s \Vdash e \ : \ \tau \\
    % lam app
    \sigma \Vdash (\lambda x : \tau_1 .e) \ v : \tau &\rightsquigarrow \sigma[x
    \mapsto v :_1 \tau_1] \Vdash e : \tau \\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % more boring rules
    % op(v) rule
    \sigma \Vdash \mathbf{op}(v) : \tau &\rightsquigarrow \sigma \Vdash op(v) :
    \tau \\
    % proj rule
    \sigma \Vdash \pi_i\langle v_1,v_2 \rangle : \tau &\rightsquigarrow \sigma
    \Vdash v_i : \tau \\ 
  \end{aligned}
\end{equation*}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % sharing rule 
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \vskip 0.3em
    \AXC{$\sigma \Vdash e_1 : \tau_1 \rightsquigarrow^* \sigma_1 \Vdash e_1' : \tau_1$}
    \AXC{$\sigma \Vdash e_2 : \tau_2 \rightsquigarrow^* \sigma_2' \Vdash e_2' : \tau_2$}
    \BIC{$\sigma \Vdash \langle e_1, e_2 \rangle \ : \tau
    \rightsquigarrow \sigma_1' \cap \sigma_2' \Vdash \langle e_1', e_2'
    \rangle : \tau$}
    % todo: define \sigma
    \DisplayProof

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % misc stepping rules
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \vskip 0.3em
    \AXC{$\sigma \Vdash e : \tau_1 \rightsquigarrow \sigma' \Vdash e' : \tau_2$}
    \UIC{$\sigma \Vdash \textbf{let}^* \ x = e \ : \tau_1 \ \tin \ \tau_2
    \rightsquigarrow \sigma' \Vdash \textbf{let}^* \ x = e' \ : \tau_1 \
    \tin \ \tau_2$}
    \DisplayProof

    \vskip 0.3em
    \AXC{$\sigma \Vdash e : \tau_1 \rightsquigarrow \sigma' \Vdash e' : \tau_1'$}
    \UIC{$\sigma \Vdash \factor e \ : \tau \rightsquigarrow \sigma' \Vdash
    \factor e' : \tau $}
    \DisplayProof

\end{center}
    \caption{Enviroment-style evaluation rules for \Lang, ordered by precedence. Note that during type
    checking but prior to running the operational semanitcs, the sensitivity
    information (tracked with metavar $s$) and type of bound variables $\tau_1,
    \tau_2$, is preserved as annotations in the syntax, written $[e]_s$ and
    $\textbf{let-bind}_{(s, \tau_1)}$, $\textbf{let-cobind}_{(s, t, \tau_1)}$,
    and $\lambda x : \tau_1 . e $. Note that $\textbf{let}^*$ is syntactic sugar
    for matching all let expressions and their corresponding annotations.}
    \label{fig:sub_eval_rules}
\end{figure}
