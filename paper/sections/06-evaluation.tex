\section{Type inference}

\subsection{Subtyping}
We extend the subtyping relation from \cite{NumFuzz} to work with interval
bounds in the following way:

$$
\begin{aligned}[c]
\textbf{num}_{(k_0, k_1)} \sqsubseteq \textbf{num}_{(k'_0, k'_1)} \triangleq 
k'_0 \leq k_0 \leq k_1 \leq k'_1 \\
\textbf{num}_{i} \sqsubseteq \textbf{num}_{i'} \triangleq 
\forall \sigma : \Delta, \
\textbf{num}_{i}~[\sigma] \sqsubseteq \textbf{num}_{i'}~[\sigma]
\end{aligned}
$$

\begin{theorem}[Admissibility of subtyping]
  The typing judgement $\Delta \ | \ \Gamma \vdash e : \tau$ is derivable if
  $\Delta \ | \ \Gamma \vdash e : \tau'$ has a derivation and $\tau \sqsubseteq
  \tau'$.
\end{theorem}
\begin{proof}
  The admissibility of subtyping follows from the proof in \cite{NumFuzz} and the
new interval widening rule in our type system, corresponding to the
$\textbf{num}$ subtyping case.
\end{proof}

\subsection{Algorithmic Type Inference}

Conceptually, we can think of our type inference and checking algorithm in two
stages. Users write programs in \Lang. We then perform the type sensitivity and
inference algorithm developed in \cite{NumFuzz}, extended to our core language
without bound polymorphism. Finally, we automatically infer polymorphic bound
annotations to generate a valid typing derivation of the program in \bnd{\Lang}.

\begin{equation}
  \begin{aligned}[c]
    add &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}} \\
    sub &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 - \epsilon_1}} \\
    mult &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 \cdot \epsilon_1}} \\
  \end{aligned}
\end{equation}

\begin{example}[Unannotated program]
  \begin{equation}
    \lambda x \ . \ \mathbf{let} \ s \ = \ add \ x \ \tin \ (\mathbf{rnd} \ s)
    : \textbf{num} \times \textbf{num} \multimap \textbf{num}
  \end{equation}
\end{example}
\begin{example}[Annotated program]
  \begin{equation}
    \bnd{\Lambda \epsilon_0, \epsilon_1 \ .} \lambda x : num_{\bnd{\epsilon_0}}
    \times num_{\bnd{\epsilon_1}} \ . \ 
    \mathbf{let} \ s \ = \ add \ \bnd{\{\epsilon_0\}} \ \{\bnd{\epsilon_1\}} \ x
    \ \tin \ (\mathbf{rnd} \ s)
    : 
    \bnd{\forall \epsilon_0, \epsilon_1 \ .} \ 
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap
    \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}}
  \end{equation}
\end{example}

\subsection{Problem setup}
We define two erasure operations over terms, types and contexts. Full typing contexts
can be seen as maps from variables to pairs of sensitivities and types. 

\begin{definition}[Sensitivity and round-off erasure]
For a fully annotated typing context $\Gamma$, a fully erased typing context
$\Gamma^{\bullet} = \Gamma \circ (map \ \pi_2)$ with all sensitivity and
round-off information erased.
\end{definition}

\begin{definition}[Bound erasure]
We define bound erasure ($-^{\bnd{\bullet}}$) over types and terms below:
\begin{equation}
\begin{aligned}[c]
\textbf{unit}^{\bnd{\bullet}} &\triangleq \textbf{unit} \\
\textbf{num}_i^{\bnd{\bullet}} &\triangleq \textbf{num} \\
(!_s \tau)^{\bnd{\bullet}} &\triangleq !_s \tau^{\bnd{\bullet}} \\
(M_u \tau)^{\bnd{\bullet}} &\triangleq M_u \tau^{\bnd{\bullet}} \\
(\forall \epsilon . \tau)^{\bnd{\bullet}} &\triangleq \tau^{\bnd{\bullet}} \\
(\tau_0 \times \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \times \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \otimes \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \otimes \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \multimap \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \multimap \tau_1^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation}

We similarly define an erasure operation for terms:
\begin{equation}
\begin{aligned}[c]
(e \{ i \})^{\bnd{\bullet}} &\triangleq e  \\
(\Lambda \epsilon . e)^{\bnd{\bullet}} &\triangleq e \\
e^{\bnd{\bullet}} &\triangleq e &\text{otherwise} 
\end{aligned}
\end{equation}
\end{definition}

\begin{definition}[Type inference and checking problem]
Given an erased program $e^{\bnd{\bullet}}$, produce a derivation of $. \vdash e
: \tau$ for $e$ in \Lang if such a derivation exists. 
\end{definition}

\subsection{Inference algorithm}
We write our inference algorithm this like:
$$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$$
where we start a program with a typing context $\Gamma^{\bullet}$ that has
erased sensitivity information (but with bound variables) and an erased program
$e^{\bnd{\bullet}}$ with no polymorphic bounds, and produces a typing context
$\Gamma$ with sensitivity information and fully annotated program e and type
$\tau$ such that
$\Delta \ | \ \Gamma' \vdash e' : \tau$
is derivable for some $\Delta$ (our soundness criterion). We start type
inference by passing the empty context (written .), along with the bound-erased
program (written $e^{\bnd{\bullet}}$) to the inference algorithm.

Our type inference algorithm occurs in two stages, starting from an erased
program (with no $\Lambda$ or polymoprhic instantiations) and sensitivity erased
typing context $\Gamma^{\bullet}$:
\begin{enumerate}
  \item We infer sensitivities via the type inference algorithm
  provided in \cite{NumFuzz}, extended to deal with our new $\mathbf{factor}$
  primitive and interval bounds (Section~\ref{sec:sen-type-infer}). 
  $$\Gamma^{\bullet}; e^{\bnd{\bullet}} \underset{sens.}{\implies} \Gamma;
  e^{\bnd{\bullet}}; \tau^{\bnd{\bullet}}$$

  \item We infer bounds (Section~\ref{sec:bnd-type-infer}):
  $$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau'$$
\end{enumerate}
The full type inference algorithm is $\implies \triangleq
\underset{bnd.}{\implies} \circ \underset{sens.}{\implies}$, throwing away the
intermediate $\tau'$. The construction is detailed below.

\subsubsection{Stage 1/2: Sensitivity and round-off inference}
\label{sec:sen-type-infer}
Our sensitivity inference algorithm extends the inference algorithm presented in
\cite{NumFuzz} with the following case for \textbf{factor}
(Figure~\ref{fig:factor-type-infer}).

\begin{figure} 
\begin{center}
\RightLabel{(\textbf{factor})}
\AXC{$\Gamma^{\bullet}; e \underset{sens.}{\implies} \Gamma;
e^{\bnd{\bullet}}; (M_q~\tau_0 \times M_r~\tau_1)^{\bnd{\bullet}}$}
\UIC{$\Gamma^{\bullet}; \mathbf{factor}~e^{\bnd{\bullet}} \underset{sens.}{\implies}
\Gamma; \mathbf{factor}~e^{\bnd{\bullet}};
M_{max(q,r)}~(\tau_0 \times \tau_1)^{\bnd{\bullet}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\end{center}
    \caption{Rule for factor sensitivity inference. Note that $q,r$ are concrete
    numbers so $max(q,r)$ is a concrete, computable number as well.}
    \label{fig:factor-type-infer}
\end{figure}

\subsubsection{Stage 2/2: Bound inference} \label{sec:bnd-type-infer}
The goal of this stage of type inference, then, is to take a program
$e^{\bnd{\bullet}}$ in context $\Gamma$ and produce a program and with type in
context, possibly using bound polymorphism.

\begin{figure}
%% ROW1
\begin{center}
\begin{equation}
\begin{aligned}[c]
\end{aligned}
\end{equation}

\AXC{}
\UIC{$I(\textbf{unit}^{\bnd{\bullet}}, \Delta) \to \textbf{unit}; .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% \AXC{$\epsilon \not \in FTV(\Gamma) \cup DOM(\Delta)$}
\AXC{$\epsilon \text{ globally fresh}$}
\UIC{$ I(\textbf{num}^{\bnd{\bullet}}, \Delta) \to \textbf{num}_{\epsilon};
\epsilon $}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}},\Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \times \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \times
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \otimes \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \otimes
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 + \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 + \tau_1; \alpha,
\beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \multimap \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \multimap
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau^{\bnd{\bullet}}, \Delta) \to \tau; \beta$}
\UIC{$I(!_s (\tau^{\bnd{\bullet}}), \Delta) \to !_s \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau^{\bnd{\bullet}}, \Delta) \to \tau; \beta$}
\UIC{$I(M_u (\tau^{\bnd{\bullet}}), \Delta) \to M_u \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\vskip 3em

\AXC{}
\UIC{$E(\textbf{unit}, \Delta) \to .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$\epsilon \text{ globally fresh}$}
\UIC{$E(\textbf{num}_i, \Delta) \to i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \times \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \otimes \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 + \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \multimap \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau, \Delta) \to \beta$}
\UIC{$E(!_s (\tau), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau, \Delta) \to \beta$}
\UIC{$E(M_u (\tau), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Ancillary functions for defining algorithmic type inference.}
    \label{fig:helper_type_inference}
\end{figure}

\newpage

\begin{figure}
\begin{center}
%% unit
\AXC{}
\RightLabel{(Unit)}
\UIC{$\Gamma; \langle \rangle^{\bnd{\bullet}}; \underset{bnd.}{\implies} \Gamma;
\langle \rangle; \textbf{unit}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% var
\AXC{}
\RightLabel{(Var)}
\UIC{$\Gamma, x :_s \tau, x^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma, x
:_s \tau; x; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%% bang intro
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau$}
\RightLabel{($!$ I)}
\UIC{$s * \Gamma; [e]_{\annotate{s}}^{\bnd{\bullet}} \underset{bnd.}{\implies} s
* \Gamma; [e']_{\annotate{s}}; !_s~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% fun
\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \epsilon_0, \ldots, \epsilon_n$}
\AXC{$\Gamma, x : \tau_0; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma, x
:_s \tau_0; e'; \tau$}
% \AXC{$\epsilon_0, \ldots, \epsilon_n \not\in FTV(\Gamma) \cup DOM(\Delta)$}
\RightLabel{($\multimap$ I)}
\BIC{$\Gamma; \lambda (x : \annotate{\tau_0^{\bnd{\bullet}}}). e^{\bnd{\bullet}}
\underset{bnd.}{\implies} \Gamma; \Lambda \epsilon_0, \ldots, \epsilon_n
(\lambda (x : \tau_0) . e'); \forall \epsilon_0, \ldots, \epsilon_n . \ \tau_0
\multimap \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

% %% imp elim
% \AXC{$\Delta \ | \ \Gamma^{\bullet}; f^{\bullet} \implies \Delta'_0 \ | \ \Gamma_0; f; \tau_0 \multimap \tau$}
% \AXC{$\Delta \ | \ \Gamma^{\bullet}; e^{\bullet} \implies \Delta'_1 \ | \ \Gamma_1; e; \tau'_0$}
% \AXC{$\tau'_0 \sqsubseteq \tau_0$}
% \RightLabel{($\multimap$ E)}
% \TIC{$\Delta \ | \ \Gamma^{\bullet}; f^{\bullet}~e^{\bullet} \implies \Delta_0 +
% \Delta_1 \ | \ \Gamma_0 + \Gamma_1 ; f~e; \tau$}
% \bottomAlignProof
% \DisplayProof
% \vskip 1em

%% imp elim, forall
\AXC{$
\begin{aligned}[t]
\Theta; f^{\bnd{\bullet}} &\underset{bnd.}{\implies} \Theta; f'; \forall
\epsilon_0, \ldots, \epsilon_n \ . \ \tau_0 \multimap \tau \\
\Gamma; e^{\bnd{\bullet}} &\underset{bnd.}{\implies} \Gamma; e'; \tau'_0 \\
\end{aligned} $}
\hskip 0.5em
\AXC{$\begin{aligned}[t]
E(\tau_0) &\to i_0, \ldots, i_n \\
\tau'_0 &\sqsubseteq \tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] \\
\end{aligned}
$}
\AXC{$
\begin{aligned}[t]
\tau &\mapsto^{*} \tau' \\
\tau' &\not\mapsto 
\end{aligned}
$}
\RightLabel{($\multimap$ E)}
\TIC{$\Gamma + \Theta; (f~e)^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma +
\Theta; (f'~\{ i_0 \}~\ldots~\{ i_n \})~e'; \tau'$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{op})}
\AXC{$\{\textbf{op} : \tau\} \in \Sigma$}
\UIC{$\Gamma; \textbf{op}^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma;
\textbf{op}; \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\RightLabel{(\textbf{factor})}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; (M_q
\tau_0 \times M_r \tau_1)$}
\UIC{$\Gamma; \textbf{factor}~e^{\bnd{\bullet}} \underset{bnd.}{\implies}
\Gamma; \textbf{factor}~e'; M_{max(q, r)} (\tau_0 \times \tau_1)$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Structural rules below                            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 1em

%% Ret
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau$}
\RightLabel{(\textbf{Ret})}
\UIC{$\Gamma; \textbf{ret}~e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma;
\textbf{ret}~e'; M_0~\tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% Rnd
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau$}
\RightLabel{(\textbf{Rnd})}
\UIC{$\Gamma; \textbf{rnd}~e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma;
\textbf{rnd}~e'; M_q~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% times intro 
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau_0$}
\AXC{$\Gamma; f^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; f'; \tau_1$}
% \AXC{$
% \begin{aligned}[t]
% \Delta'_0 \sqsubseteq \Delta' \\
% \Delta'_1 \sqsubseteq \Delta' \\
% \end{aligned}
% $}
% \AXC{$
% \begin{aligned}[t]
% \Gamma'_0 \sqsubseteq \Gamma' \\
% \Gamma'_1 \sqsubseteq \Gamma' \\
% \end{aligned}
% $}
\RightLabel{($\times$ I)}
\BIC{$\Gamma; \langle f, e \rangle^{\bnd{\bullet}} \underset{bnd.}{\implies}
\Gamma; \langle f', e' \rangle; \tau_0 \times \tau_1$}
\bottomAlignProof
\DisplayProof
\RightLabel{($\times$ E)}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau_0
\times \tau_1$}
\UIC{$\Gamma; (\pi_i~e)^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma;
\pi_i~e'; \tau_i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% otimes intro 
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau_0$}
\AXC{$\Theta; f^{\bnd{\bullet}} \underset{bnd.}{\implies} \Theta; f'; \tau_1$}
\RightLabel{($\otimes$ I)}
\BIC{$\Gamma + \Theta; \langle f, e \rangle^{\bnd{\bullet}}
\underset{bnd.}{\implies} \Gamma + \Theta; (f', e'); \tau_0 \otimes \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let})}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau_0$}
\AXC{$\Theta, x; f^{\bnd{\bullet}} \underset{bnd.}{\implies} \Theta, x :_s
\tau_0; f'; \tau$}
\BIC{$s * \Gamma + \Theta; (\textbf{let} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \underset{bnd.}{\implies} s * \Gamma + \Theta; \textbf{let} \
x \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-pair})}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Delta_0 \ | \ \Gamma;
e'; \tau_0 \otimes \tau_1$}
\AXC{$\Theta, x, y; f^{\bnd{\bullet}} \underset{bnd.}{\implies} \Delta_1 \ | \
\Theta, x :_s \tau_0, y :_s \tau_1; f'; \tau$}
\BIC{$s * \Gamma + \Theta; (\textbf{let-pair} \ (x, y) \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \underset{bnd.}{\implies} s * \Gamma + \Theta;
\textbf{let-pair} \ (x, y) \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-bind})}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e';
M_r~\tau_0$}
\AXC{$\Theta, x:_s \tau_0; f^{\bnd{\bullet}} \underset{bnd.}{\implies} \Theta, x
:_s \tau_0; f; M_q~\tau$}
\BIC{$s * \Gamma + \Theta; (\textbf{let-bind} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \underset{bnd.}{\implies} s * \Gamma + \Theta;
\textbf{let-bind} \ x \ = \ e' \ \textbf{in} \ f'; M_{s*r + q}~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{case})}
\AXC{$\Gamma; e^{\bnd{\bullet}} \underset{bnd.}{\implies} \Gamma; e'; \tau_0 +
\tau_1$}
\AXC{$\Theta, x :_s \tau_0 ; f_1^{\bnd{\bullet}} \underset{bnd.}{\implies}
\Theta, x :_s \tau_0; f'_1; \tau$}
\AXC{$\Theta, x :_s \tau_0 ; f_2^{\bnd{\bullet}} \underset{bnd.}{\implies}
\Theta, x :_s \tau_0; f'_2; \tau$}
\TIC{$s * \Gamma + \Theta; (\textbf{case} \ e \ \textbf{of} \
(\textbf{in}_1~x.f_1 ~ | ~ \textbf{in}_2~x.f_2))^{\bnd{\bullet}}
\underset{bnd.}{\implies} s * \Gamma + \Theta; (\textbf{case} \ e' \ \textbf{of}
\ (\textbf{in}_1~x.f'_1 ~ | ~ \textbf{in}_2~x.f'_2)) ; M_{s*r + q}~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\end{center}
    \caption{Algorithmic rules. \annotate{Red text} are user-required
    annotations. To help define the $\underset{bnd.}{\implies}$ relation, we
    define a $\to$ relation that annotates (removes the bullet) for a given
    type.}
    \label{fig:type_inference}
\end{figure}

\begin{lemma}[Elimination between $I$ and $E$.]
Pick some type $\tau$.
Let $\tau'; \epsilon_0, \ldots, \epsilon_n = I(\tau^{\bnd{\bullet}})$.
Let $i_0, \ldots i_n = E(\tau)$.
Then, $\tau = \tau'[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$.
\end{lemma}
\begin{proof}
Holds by induction over types.
\end{proof}

\begin{theorem}[Algorithmic Soundness] \label{thm:algo-soundness}
If $\Gamma^{\bullet}; e^{\bullet} \implies \Gamma'; e'; \tau'$ then there is some
$\Delta$ such that $\Delta \ | \ \Gamma \vdash e' : \tau$ has a typing derivation.
\end{theorem}
\begin{proof}
Note that the full algorithm is the fused combination of the
$\underset{bnd.}{\implies}$ and $\underset{sens.}{\implies}$ algorithms. For
example, the var case for the full algorithm looks like (throwing away the
intermediate $\tau$):
\begin{equation}
\frac
{}
{\Gamma^{\bullet}, x : \tau; x^{\bnd{\bullet}} \underset{sens.}{\implies}
\Gamma^0, x :_1 \tau; x^{\bnd{\bullet}}; \tau \underset{bnd.}{\implies} \Gamma
:_s \tau; x; \tau}
\end{equation}
We induct over each typing / case in the full algorithm. Many of the cases that
follow from the soundness proof for $\underset{sens.}{\implies}$
(in~\cite{NumFuzz}), We detail the cases for which $\underset{bnd.}{\implies}$
is non-structural below:
\begin{description}
  \item[$\textbf{unit}$.] Holds trivially.
  \item[Var.] Holds trivially.
  \item[$\multimap$ I.] Apply $\forall-I$ for every free $\epsilon$.
  \item[$\multimap$ E.] Apply $\forall-E$ for every bound $\epsilon$.
  \item[$\textbf{op}$.] Holds trivially.
  \item[$\textbf{factor}$.] Holds by application of the inductive hypothesis.
\end{description}
\end{proof}

\section{Implementation and language instantiation}
