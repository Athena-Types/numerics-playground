\section{More precise treatement of addition and subtraction} \label{sec:structure}
% Outline:
% 1. Associativity, minimal example on add. (Running example)
% 2. Zoom back out, also bad for sub (give example)
% 3. Generalize towards arbitrary trees (by example)
% 4. Concluding remarks for arbitrary programs

We return to our example program from Section~\ref{sec:overview} whose type is
$M_{3 \cdot u} \ \textbf{num}$:
\begin{equation*}
  \begin{aligned}[c]
    \textbf{let-bind} \ q \ = \ \textbf{rnd} \ (\textbf{add} \ \langle w, x \rangle) \ \textbf{in} \  \\
    \textbf{let-bind} \ p \ = \ \textbf{rnd} \ (\textbf{add} \ \langle y, z \rangle) \ \textbf{in} \  \\
    \textbf{rnd} \ (\textbf{add} \  \langle q, p \rangle  )
  \end{aligned}
\end{equation*}
We would expect that the more efficient pairwise summation algorithm to have a
one-third tighter error bound than the iterative summation algorithm ($((w
\tilde{+} x) \tilde{+} y) \tilde{+} z$) shown: 
\begin{equation*}
  \begin{aligned}[c]
    \textbf{let-bind} \ q \ = \ \textbf{rnd} \ (\textbf{add} \ \langle w, x \rangle) \ \textbf{in} \  \\
    \textbf{let-bind} \ p \ = \ \textbf{rnd} \ (\textbf{add} \ \langle q, y \rangle) \ \textbf{in} \  \\
    \textbf{rnd} \ (\textbf{add} \  \langle p, z \rangle  )
  \end{aligned}
\end{equation*}
However, this program results in the same type and error bound as the pairwise
summation algorithm.

To better understand the restrictions imposed by the type system, we include the
relevant portions of the typing trees for the above two programs in
Figure~\ref{fig:partial-typing-trees}. 
In subfigure (a), we show the typing tree corresponding to the pairwise
summation algorithm on four numbers. In subfigure (b), we show the typing tree
corresponding to the iterateive summation algorithm on four numbers. In
subfigure (c) we highlight that the error grade for both algorithms are the same
due to structural limitations of the $\textbf{let-bind}$ typing rule.
Note that although the underlying arithmetic computation of our pairwise
summation program corresponds to a perfect binary tree, the grades on the
corresponding typing tree itself does not reflect this.

\begin{figure}[hbtp]
  \scriptsize
  % \footnotesize
  % \small
\centering
\vspace{1em}

\begin{subfigure}[t]{1.0\textwidth}
  \centering
%   \AXC{\ldots}
%   \UIC{$\vdash \textbf{add} : \textbf{num} \times \textbf{num} \multimap \textbf{num}$}
%   \AXC{$\ldots$}
% % \RightLabel{($\multimap$ E)}
% \BIC{$w, x :_1 \textbf{num} \vdash \textbf{add} \ \langle w, x \rangle : \textbf{num}$}
\AXC{\ldots}
% \LeftLabel{(Rnd)}
\UIC{$w, x :_1 \textbf{num} \ \vdash \textbf{rnd} \ (\textbf{add} \ \langle w, x \rangle) : M_u \
\textbf{num}$}
\AXC{\ldots}
\UIC{$y, z :_1 \textbf{num} \vdash \textbf{rnd} (\textbf{add} \ \langle y, z \rangle) : M_u \ \textbf{num}$}
\AXC{\ldots}
\UIC{$q, p :_{1} \textbf{num} \vdash  \textbf{rnd} (\textbf{add} \  \langle p, q \rangle) : M_{u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$y, z, q :_1 \textbf{num} \vdash
    \textbf{let-bind} \ p \ = \ \textbf{rnd} (\textbf{add} \ \langle y, z \rangle) \ \textbf{in} \ 
    \textbf{rnd} (\textbf{add} \  \langle p, q \rangle)
  : M_{u + u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$w, x, y, z :_1 \textbf{num} \ \vdash 
    \textbf{let-bind} \ q \ = \ \textbf{rnd} (\textbf{add} \ \langle w, x \rangle) \ \textbf{in} \ 
    (\textbf{let-bind} \ p \ = \ \textbf{rnd} (\textbf{add} \ \langle y, z \rangle) \ \textbf{in} \ 
    \textbf{rnd} (\textbf{add} \  \langle p, q \rangle  ))
  : M_{u+2u} \ \textbf{num}$}
\bottomAlignProof
\DisplayProof
\caption{
  A partial typing tree of the program representing the pairwise summation
  algorithm on four numbers.
}
\end{subfigure}

\vspace{2em}

\begin{subfigure}[t]{1.0\textwidth}
  \centering
%   \AXC{\ldots}
%   \UIC{$\vdash \textbf{add} : \textbf{num} \times \textbf{num} \multimap \textbf{num}$}
%   \AXC{$\ldots$}
% % \RightLabel{($\multimap$ E)}
% \BIC{$w, x :_1 \textbf{num} \vdash \textbf{add} \ \langle w, x \rangle : \textbf{num}$}
\AXC{\ldots}
% \LeftLabel{(Rnd)}
\UIC{$w, x :_1 \textbf{num} \ \vdash \textbf{rnd} \ (\textbf{add} \ \langle w, x \rangle) : M_u \
\textbf{num}$}
\AXC{\ldots}
\UIC{$y, q :_1 \textbf{num} \vdash \textbf{rnd} (\textbf{add} \ \langle q, y \rangle) : M_u \ \textbf{num}$}
\AXC{\ldots}
\UIC{$z, p :_{1} \textbf{num} \vdash  \textbf{rnd} (\textbf{add} \  \langle p, z \rangle) : M_{u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$y, z, q :_1 \textbf{num} \vdash
    \textbf{let-bind} \ p \ = \ \textbf{rnd} (\textbf{add} \ \langle q, y \rangle) \ \textbf{in} \ 
    \textbf{rnd} (\textbf{add} \  \langle p, z \rangle)
  : M_{u + u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$w, x, y, z :_1 \textbf{num} \ \vdash 
    \textbf{let-bind} \ q \ = \ \textbf{rnd} (\textbf{add} \ \langle w, x \rangle) \ \textbf{in} \ 
    (\textbf{let-bind} \ p \ = \ \textbf{rnd} (\textbf{add} \ \langle q, y \rangle) \ \textbf{in} \ 
    \textbf{rnd} (\textbf{add} \  \langle p, z \rangle  ))
  : M_{u+2u} \ \textbf{num}$}
\bottomAlignProof
\DisplayProof
\caption{
  A partial typing tree of the program representing the iterative summation
  algorithm on four numbers.
}
\end{subfigure}

\vspace{2em}

\begin{subfigure}[t]{1.0\textwidth}
  \centering
%   \AXC{\ldots}
%   \UIC{$\vdash \textbf{add} : \textbf{num} \times \textbf{num} \multimap \textbf{num}$}
%   \AXC{$\ldots$}
% % \RightLabel{($\multimap$ E)}
% \BIC{$w, x :_1 \textbf{num} \vdash \textbf{add} \ \langle w, x \rangle : \textbf{num}$}
\AXC{\ldots}
% \LeftLabel{(Rnd)}
\UIC{$\ldots \vdash M_u \ \textbf{num}$}
\AXC{\ldots}
\UIC{$\ldots \vdash M_u \ \textbf{num}$}
\AXC{\ldots}
\UIC{$\ldots \vdash M_{u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$\ldots \vdash M_{u + u} \ \textbf{num}$}
% \RightLabel{($M_u$ E)}
\BIC{$\ldots \vdash M_{u+2u} \ \textbf{num}$}
\bottomAlignProof
\DisplayProof
\caption{
  A partial typing tree matching both summation algorithms. Note the grades and
  overall shape of the typing tree.
}
\end{subfigure}
\caption{
  For presentational purposes, we remove polymoprhic bound annotations from the
  $\textbf{num}$ type and $\textbf{add}$ operation and also omit the
  applications of the polymorphic typing rules.
}
\label{fig:partial-typing-trees}
\end{figure}

We observe that the primitive $\textbf{factor}: (M_q \tau_0) \times (M_q \tau_1)
\multimap M_q (\tau_0 \times \tau_1)$ is sound (proved in
Theorem~\ref{thm:metric-preservation}) and also allows for the grades in the
typing trees to be balanced by allowing  the monad to be ``factored" out of the
cartesian pair.
Armed with a new primitive and more expressive language, we now return to our
running example and provide a partial typing tree for the pairwise summation
algorithm using the \textbf{factor} primitive in
Figure~\ref{fig:factor-example}. 
The type of the pairwise summation program with $\textbf{factor}$ is $M_{2\cdot
u} \ \textbf{num}$, lower than the $2 \cdot u$ error grade of the iterative
summation program.
\begin{figure}
  \scriptsize
  \centering
  \AXC{\ldots}
  \UIC{$w, x, y, z :_1 \textbf{num} \vdash 
            \langle 
            \textbf{rnd} \ (\textbf{add} \langle w, x \rangle),
            \textbf{rnd} \ (\textbf{add} \langle y, z \rangle)
            \rangle
          : (M_u \ \textbf{num}) \times (M_u \textbf{num}) $}
  \UIC{$w, x, y, z :_1 \textbf{num} \vdash 
  \textbf{factor} \
            \langle 
            \textbf{rnd} \ (\textbf{add} \langle w, x \rangle),
            \textbf{rnd} \ (\textbf{add} \langle y, z \rangle)
            \rangle
          : M_u \ (\textbf{num} \times \textbf{num}) $}
  \AXC{\ldots}
  \UIC{$a:_{s} \textbf{num} \times \textbf{num} \vdash \textbf{rnd} \ (\textbf{add} \ a) : M_{u} \ \textbf{num}$}
  \BIC{$w, x, y, z :_1 \textbf{num} \vdash 
        \textbf{let-bind} \ a \ = \textbf{factor} \
          \langle 
          \textbf{rnd} \ (\textbf{add} \langle w, x \rangle),
          \textbf{rnd} \ (\textbf{add} \langle y, z \rangle)
          \rangle \ \textbf{in} \
        \textbf{rnd} \ (\textbf{add} \ a) : M_{u + u} \ \textbf{num}$}
\bottomAlignProof
\DisplayProof
\caption{
  A partial typing tree for the pairwise summation algorithm using the
  $\textbf{factor}$ primitive. Note how the $\textbf{factor}$ primitive lets us
  ``share" the $u$ monadic error grade on the left-hand-side of the typing tree.
}
\label{fig:factor-example}
\end{figure}
As \textbf{add} and \textbf{sub} have the same type, the same proceses of
rewriting with \textbf{factor} can be accomplished in the same manner with
$\textbf{sub}$. In Figure~\ref{fig:factor-sub-example}, we demonstrate how to
use $\textbf{factor}$ to achieve tighter error bounds for programs with
subtraction. 
Clearly, $\textbf{factor}$ helps users design programs that achieve tighter
error bounds.

\begin{figure}[ht] 
\centering

\begin{subfigure}[t]{0.48\textwidth}
  \vspace{0.6em}
  \begin{equation*}
    \begin{aligned}[c]
      \textbf{let-bind} \ q \ = \ \textbf{rnd} \ (\textbf{sub} \ \langle w, x \rangle) \ \textbf{in} \  \\
      \textbf{let-bind} \ p \ = \ \textbf{rnd} \ (\textbf{sub} \ \langle y, z \rangle) \ \textbf{in} \  \\
      \textbf{rnd} \ (\textbf{sub} \  \langle q, p \rangle  )
    \end{aligned}
  \end{equation*}
\caption{Without factor: the type assigned is $M_{3u} \ \textbf{num}$.}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.48\textwidth}
  \begin{equation*}
    \begin{aligned}[c]
      \textbf{let-bind} \ a \ = \\ \textbf{factor} \
        \langle 
        \textbf{rnd} \ (\textbf{sub} \langle w, x \rangle),
        \textbf{rnd} \ (\textbf{sub} \langle y, z \rangle)
        \rangle \ \textbf{in} \\
        \textbf{rnd} \ (\textbf{sub} \ a)
    \end{aligned}
  \end{equation*}
\caption{Without factor: the type assigned is $M_{2u} \ \textbf{num}$.}
\end{subfigure}

\caption{Side-by-side comparison of subtraction with and without the
\textbf{factor} primitive. Note that we omit the bounds subscripts for
presentational purposes.}
\label{fig:factor-sub-example}
\end{figure}

Note that even though $\textbf{factor}$ has computational content (it
reassociates the values), all programs rewritten with \textbf{factor} in this
section and our artifact are observationally equivalent with and without
\textbf{factor}.
So, we can often rewrite any subprogram with sequences of addition or
subtraction into a subprogram utilizing \textbf{factor}.
As many (sub)programs contain addition and subtraction, we are often able to
improve error bounds by rewriting a program with \textbf{factor}.

Further, we observe that that the bounds subscript on $\textbf{num}$ are the
same in all of our example and benchmark programs for programs rewritten with
and without \textbf{factor}.
By a simple inspection of our error theorems
(Theorem~\ref{thm:paired-a-priori-abs} and
Theorem~\ref{thm:paired-a-priori-rel}), this means that using \textbf{factor}
often leads to a strictly lower total error bound. In Section~\ref{sec:eval}, we
compare the error bounds for programs written with factor.

\subsection{Other related primitives}
We now explore whether our typing rules can derive the equivalence between $M_q
(\tau_0 \times \tau_1)$ and $M_q \tau_0 \times M_q \tau_1$.
Interestingly, the inverse type 
$\textbf{distribute} : M_q (\tau_0 \times \tau_1) \multimap (M_q \tau_0) \times (M_q \tau_1)$
is derivable, so no special primitive is needed to structure arithmetic in the
reverse direction:
\begin{equation*} \label{eq:distribute}
\begin{aligned}[c]
\textbf{distribute} &: M_q (\tau_1 \times \tau_2) \multimap (M_q \tau_1 \times M_q \tau_2) \\
 & \triangleq \lambda ~ y. ~ 
   \langle
     \textbf{let-bind} \ x ~ = ~ y \ \textbf{in} \ \textbf{ret}(\pi_1 ~ x),
     \textbf{let-bind} \ x ~ = ~ y \ \textbf{in} \ \textbf{ret}(\pi_2 ~ x),
   \rangle
\end{aligned}
\end{equation*}
Further, the comonadic sequencing rule does not have such a corresponding
restriction as both
\begin{equation}
  \begin{aligned}[c]
  \textbf{cofactor} &: (!_s \tau_0) \times (!_s \tau_1) \multimap !_s (\tau_0 \times \tau_1) \\
  \textbf{cofactor} &\triangleq \lambda e. [\langle \textbf{let-cobind} \ x \ = \ \pi_0 \ e \ \textbf{in} \ x , \textbf{let-cobind} \ y \ = \ \pi_1 \ e \ \textbf{in} \ y \rangle]\\
  \end{aligned}
\end{equation}
and
\begin{equation}
  \begin{aligned}[c]
    \textbf{codistribute} &: !_s (\tau_0 \times \tau_1) \multimap (!_s \tau_0) \times (!_s \tau_1) \\
    \textbf{codistribute} &\triangleq \lambda e. \textbf{let-cobind} \ x \ = \ e \ \textbf{in} \ \langle [\pi_0 ~ x], [\pi_1 ~ x] \rangle \\
  \end{aligned}
\end{equation}
are derivable.

% In particular, the ability for a producer to share resources interacts poorly with our
% sequenced $\textbf{let-bind}$ and call-by-value evaluation strategy, which
% pessimistically prohibits the sharing of resources between the bound argument
% and the body. If we have two monadic types $M_q \tau_0 \times M_q \tau_1$ that
% shared resources in their construction, we have no way of constructing $M_q
% (\tau_0 \times \tau_1)$ with a shared error grade. A similar problem exists for
% sharing context sensitivities. 

% \subsection{Automatic inference of factor}
% We now describe an automatic program transformation $\textsc{factorize}$ that
% can insert $\textbf{factor}$ in a program that is strictly sequenced without
% $\textbf{factor}$. We assume that each variable is unique (no shadowing).
%
% We first recusively transform the program so that it is in administrative normal
% form. In particular, we desire that every application is of an
% expression to a variable (e.g. $e \ x$) or operation to a variable (e.g.
% $\textbf{op} \ y$). 
% % The non-structural cases of the transformation are provided below:
% %
% % \begin{equation}
% %   \begin{aligned}[c]
% %     \textsc{preprocess}(e \ f) &= \textbf{let} \ x \ = \ f \ \textbf{in} \ e \ x \quad \quad &\text{ (for $f$ not a variable)} \\
% %     \textsc{preprocess}(\textbf{op} \ e) &= \textbf{let} \ x \ = \ e \ \textbf{in} \ \textbf{op} \ x \quad \quad &\text{ (for $e$ not a variable)} 
% %   \end{aligned}
% % \end{equation}
%
% Now, we we can define $\textsc{factorize}$, which syntatically operates on pairs
% of well-typed programs in adminstrative normal form and \textit{monadic maps}
% $\sigma$, which maps variables to expressions of monadic type. These maps behave
% similarly to substutiton maps. $\textsc{transform}$ returns the transformed
% program fragment and sets of variables that have been used by factor. It has
% type:
% % max: hmm this last part doesn't quite make sense wrt sets of vars
% $$
% \textsc{factorize} : \text{program} \to (\text{var} \rightharpoonup \text{program}) \to
% (\text{program} \times \text{sets of variables})
% $$
%
% % By default, for all variables $x$, $\sigma[x] = x$ if $x$ is not
% % otherwise defined in $\sigma$.
%
% % \begin{equation}
% %   \textsc{factorize}(e) = \textsc{sequence}(\textsc{factorize-rec}(e, \emptyset))
% % \end{equation}
%
% We use $V$ as a metavariable to represent a set of variables. We first detail
% the interesting cases for our program transformation:
%
% \begin{equation}
% \begin{aligned}[c]
%   \textsc{factorize}(\textbf{let-bind} \ x \ = \ e \ \textbf{in} \ f, \sigma) &= 
%   \begin{aligned}
%     \text{let} \ (g, V) \ = (\textsc{factorize}(f, \sigma;[x \mapsto \text{fst} \ \textsc{factorize}(e, \sigma)])) \ \text{in} \\
%     \text{if} \ x \in V \\
%     \text{then} \ (g, V) \\
%     \text{else} \ (\textbf{let-bind} \ x \ = \ e \ \textbf{in} \ g, V \cup \{x\})\\
%   \text{(if x only occurs once in f)}
%   \end{aligned}
%   \\
%   \\
%   \textsc{factorize}(\textbf{let} \ z \ = \ \langle x, y \rangle \ \textbf{in} \ f, \sigma) &= 
%   \begin{aligned}
%     \text{let} \ (g, V) = \textsc{factorize}(f, \sigma) \ \text{in}\\
%     \text{if} \ x, y \in DOM(\sigma) \\
%     \text{then} \ (\textbf{let-bind} \ z = \ \textbf{factor} \ \langle \sigma[x], \sigma[y] \rangle \ \textbf{in} \ g, V \cup \{x, y\})\\
%     \text{else} \ (\textbf{let} \ z \ = \ \langle x, y \rangle \ \textbf{in} \ g,
%     V) \\
%   \end{aligned} \\
%   \\
%   \textsc{factorize}(e \ f, \sigma) &= 
%   \begin{aligned}
%     \text{let} \ (g, V_0) = \textsc{factorize}(e, \sigma) \ \text{in}\\
%     \text{let} \ (h, V_1) = \textsc{factorize}(f, \sigma) \ \text{in}\\
%     (g \ h, V_0 \cup V_1)
%   \end{aligned} \\
% \end{aligned}
% \end{equation}
% Now, we detail our base case for variables:
% \begin{equation}
%   \begin{aligned}
%     \textsc{factorize}(x, \sigma) &= (x, \{\})
%   \end{aligned}
% \end{equation}
% and our base case for constants:
% \begin{equation}
%   \begin{aligned}
%     \textsc{factorize}(k, \sigma) &= (k, \{\})
%   \end{aligned}
% \end{equation}
% The remainder of the rules are recursive and structural. Invoking the program
% transformation on a well-typed program transformation $. \vdash e : \tau$
% can be done by calling: $\textsc{factorize} ~ e ~ \emptyset$.
%
% \subsubsection{Program transformation properties}
% We now wish to prove that our program transformation is sound and never results
% in looser error bounds.
% \begin{theorem}[Factorization soundness]
%   For any program $. \vdash e : \tau$ and $(e', \sigma) = \textsc{factorize} \ e \
%   \emptyset$, we have that $. \vdash e' : \tau'$ where $\tau' \subseteq \tau$.
% \end{theorem}
% \begin{proof}
%   We first generalize the hypothesis to be over all typing contexts $\Gamma$.
%   We induct over the typing derivation. 
%   We strengthen the inductive hypothesis with the assumption that our map
%   $\sigma: \text{var} \rightharpoonup \text{program}$ only maps variables $x_0,
%   x_1, x_n$ defined in the typing context $\Gamma$ such that $\Gamma \vdash
%   \sigma[x] : M_u \ \Gamma[x]$ is well-typed and a output guarantee that for all
%   $x \in DOM(\sigma)$:
%   \begin{enumerate}
%     \item If $x \in \sigma$, $\Gamma \vdash e' : \tau'$ for $\tau' \subseteq
%       \tau$ (substitution occured with \textbf{factor}).
%     \item If $x \not\in \sigma$, $\Gamma, x : \tau \vdash e' : \tau'$ for $\tau' \subseteq
%       \tau$ (substitution did not occur, revert).
%   \end{enumerate}
%   We proceed with our induction: 
%   \begin{description}
%     \item[Base cases (variables, constants, etc.).] Holds trivially as the
%       transformation does nothing.
%     \item[Let.] TODO.
%     \item[Let-bind ($M_u E$).] TODO.
%   \end{description}
% \end{proof}
