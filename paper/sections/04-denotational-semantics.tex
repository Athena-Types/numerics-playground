\section{Denotational Semantics}

\begin{definition}[Type interpretation]
  A type $\tau$ is interpreted with $\llbracket - \rrbracket : \textit{type} \to
  \textbf{Met}$ in the same way as in the original NumFuzz system.
  % TODO: put actual definition here.
\end{definition}


\begin{definition}[Typing context interpretation]
  A typing context $\Gamma$ is interpreted with $\llbracket - \rrbracket :
  \textit{context} \to \textbf{Met}$ in the following way:
  \begin{equation}
  \begin{aligned}[c]
    \llbracket . \rrbracket &\triangleq . \\
    \llbracket \Gamma, x :_s \tau \rrbracket &\triangleq \llbracket \Gamma \rrbracket
      \times D_s \llbracket \tau \rrbracket
  \end{aligned}
  \end{equation}
\end{definition}

Recall that we only care about closed types.
Let $CV(\tau)$ be the closed values of type $\tau$ and $CE(\tau)$ be the closed
expressions of type $\tau$. Then we can define a unary logical relation over types which
capture the core information needed to prove our error soundness theorem.

\begin{definition}[Logical relation]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{R_{\tau}} &\triangleq 
      \{ e \ | \ e \in CE(\tau) \text{ and } \exists v
        \in CV(\tau) \text{ s.t. } e \mapsto^{*} v \text{ and } v \in \mathcal{VR_{\tau}} 
      \} \\
    \mathcal{VR_{\mathbf{unit}}} &\triangleq \{ \langle \rangle \} \\
    \mathcal{VR}_{\mathbf{num}_{b}} &\triangleq 
      \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} 
      \hspace{22em} \text{if } b \mapsto^* (k_0, k_1) \\
    \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} &\triangleq 
      \{ k \ | \ k \in \mathit{num} \text{ and } k_0 \leq k \leq k_1 \} \\
    \mathcal{VR_{\mathbf{\tau_0 \times \tau_1}}} &\triangleq 
      \{ \langle v, w \rangle \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 \otimes \tau_1}}} &\triangleq 
      \{ ( v, w ) \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 + \tau_1}}} &\triangleq 
      \{ \mathbf{inl}~v \ | \ v \in \mathcal{R}_{\tau_0} \} 
      \cup
      \{ \mathbf{inr}~v \ | \ v \in \mathcal{R}_{\tau_1} \} \\
    \mathcal{VR_{\mathbf{\tau_0 \multimap \tau_1}}} &\triangleq 
      \{ \lambda x . e \ | \ \forall w_0, w_1 \in \mathcal{VR}_{\tau_0}, \\ & \quad \quad \ (\lambda x.e)~w_0, (\lambda x . e)~w_1 \in
      \mathcal{R}_{\tau_1} \text{ and } \mathcal{SD}_{\tau_1}((\lambda x . e)~w_0, (\lambda x . e)~w_1) \leq
      \mathcal{SD}_{\tau_0}(w_0, w_1) \} \\
    \mathcal{VR_{\mathbf{!_s \tau}}} &\triangleq 
      \{ [~v~] \ | \ v \in \mathcal{R}_{\tau} \} \\
    % spicy hot new stuff
    \mathcal{VR_{\mathbf{M_q \tau}}} &\triangleq 
      \{ (v, w) \ | \ v, w \in \mathcal{R}_{\tau} \text{ and } \mathcal{SDV}_{\tau}(v, w)
      \leq q \} \\
    \mathcal{VR}_{\textbf{bnd}} &\triangleq \{ (k_0, k_1) \ | \ k_0 \leq k_1 \ \forall k_0, k_1 \in
    \textit{ num } \} \\
    \mathcal{VR_{\forall \epsilon. \tau}} &\triangleq 
      \{ ((k_0, k_1), v) \ | \ \forall (k_0, k_1) \in
      \mathcal{VR}_{\textbf{bnd}} \text{ s.t. } v ~ \{(k_0, k_1)\} \in
      \mathcal{R}_{\tau[(k_0, k_1) / \epsilon]}\} \\
  \end{aligned}
  \end{equation}
\end{definition}

Our definition for distance (in our dentoational semantics), $d_\tau$ and the
distance between syntactic values $\mathcal{SD}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance) and $\mathcal{SDV}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance for $\mathcal{V}$alues) are closely related. Some care is
needed to ensure that it is well-founded. We define our distance over syntactic
values as follows:

\begin{definition}[Distance between closed syntactic terms]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \mathcal{SDV}_{\tau}(v_0, v_1)
    &\text{ if } e_0 \mapsto^{*} v_0 \text{ and } e_1 \mapsto^{*} v_1 \\
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \infty &\text{ otherwise } \\
    \mathcal{SDV_{\mathbf{unit}}}(v, w) &\triangleq 0 &\text{ for } v, w =
      \langle \rangle \\
    \mathcal{SDV}_{\mathbf{num_{b}}}(k_0, k_1) &\triangleq 
      d_\mathbb{R} &\text{ for } k_0, k_1 \in \mathbb{R} \\
    \mathcal{SDV}_{\tau_0 \times \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq max(\mathcal{SDV}_{\tau_0}(v_0, w_0),~\mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 \otimes \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau_0}(v_0, w_0) + \mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 + \tau_1}(\in_i v, \in_i w) 
      &\triangleq \mathcal{SDV}_{\tau_i}(v, w)
    \\
    \mathcal{SDV}_{\tau_0 \multimap \tau_1}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\tau_0}} \mathcal{SD}_{\tau_1}(v_0~w,~v_1~w)
    \\
    % max: double check
    \mathcal{SDV}_{!_s \tau}([v], [w]) 
      &\triangleq s \cdot \mathcal{SDV}_{\tau}(v, w)
    \\
    \mathcal{SDV}_{M_q~\tau}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau}(v_0, w_0)
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k_0, k_1)) 
      &\triangleq 0 
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k'_0, k'_1)) 
      &\triangleq \infty &\text{ otherwise }
    \\
    \mathcal{SDV}_{\forall \epsilon . \tau}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\textbf{bnd}}} 
      \mathcal{SD}_{\tau_1}(v_0~\{w\},~v_1~\{w\})
    \\
    \mathcal{SDV_{\tau}}(v, w) &\triangleq \infty &\text{ otherwise } \\
  \end{aligned}
  \end{equation}
\end{definition}

The following notation is to mirror the look of the Fuzz metric perservation
theorem statement but contains differences in the setup. For example, our
logical relation is neither coinductive nor step-indexed. It is also unary,
using mutual (well-founded) recursion between the definition of a syntactic term
falling within the logical relation and the definition of the syntactic distance
between terms.

For any two closed bounds, we can write $i \sim_0 i$ or $i \sim_{\infty} i$. 
For any two closed expressions $e_0, e_1$ falling in same type relation $e_0,
e_1 \in R_\tau$ (where $\tau$ is a closed type), we can write $e_0 \sim_r e_1$
where $\mathcal{SD}_{\tau}(e_0, e_1) \leq r$. 
Generally, we can write vectors of expressions (e.g. for subsitutions) $\sigma =
\sigma_{\Delta} \ | \ \sigma_{\Gamma}, \sigma' = \sigma'_{\Delta} \ | \
\sigma'_{\Gamma}$
for a given typing context $\Delta \ | \ \Gamma$ such that: $\sigma \sim_{\gamma} \sigma'
: \Delta \ | \ \Gamma$ for a \textit{distance vector}
$\gamma = r_0, r_1, \ldots$
where
$\sigma = i_0,~i_1,~\ldots \ | \ e_0,~e_1,~\ldots$ 
and 
$\sigma' = i_0,~i_1,~\ldots \ | \ e_0,~e_1,~\ldots$ 
such that:
$$
i_0 \sim_{r_0} i'_0 : \mathbf{bnd},~i_1 \sim_{r_1} i'_1 : \mathbf{bnd},~\ldots \
| \ e_0 \sim_{r_m} e'_0 :
\tau_0~[\sigma_{\Delta}],~e_0 \sim_{r_{m+1}} e'_0 :
\tau_1~[\sigma_{\Delta}],~\ldots
$$
We also say that a substitution vector $[i_0 / \epsilon_0, i_1 / \epsilon_1, \ldots \ | \ e_1/x_1, e_2/x_2, \ldots]$ is
\textit{compatible} with a typing context 
$i_0 : \mathbf{bnd}, i_1 : \mathbf{bnd}, \ldots \ | \ x_1 : \tau_1, x_2 : \tau_2, \ldots$
if each term 
$i_0 \in \mathcal{R}_{\mathbf{bnd}}, 
i_1 \in \mathcal{R}_{\mathbf{bnd}}, 
\ldots \ | 
\ e_1 \in \mathcal{R}_{\tau_1~[\sigma_{\Delta}]}, 
e_2 \in \mathcal{R}_{\tau_2~[\sigma_{\Delta}]}, \ldots$ where all types are closed.

Our definition for the dot product of a distance vector is the same as Fuzz. We
also write, for a distance vector $\gamma$ and variable $x$, $\gamma(x)$ for the
lookup of the distance of variable $x$ in $\gamma$. If the variable $x$ is not
in the domain, $\gamma(x) = 0$ by default. From here on in the paper, we'll
treat and represent our distance vector $\gamma$ as a lookup function and assume
that there is an implicit fixed ordering on the variables.

Numerical Fuzz is a modular family of programming langauges paramterized by the
appropriate $\rho$, constant parameter $u$, and the appropriate set of numeric
computations $\Sigma$.  
We can now state a few assumptions about how the operational and static
semantics of $\mathbf{rnd}$ and $\Sigma$ (for $\mathbf{op}$) relate.
It is the proof obligation for any language designer instantiating the language
to demonstrate that these properties hold in order for our paramterized
soundness theorems to follow.
\begin{definition}[Interface for instantiating Numerical Fuzz.]
  \label{def:numfuzz-interface}
  The interface for Numerical Fuzz consists of $\rho$, $u$, $\Sigma$, and
  $\Sigma_{\mathbf{bnd}}$ such that the following properties hold: 
\begin{description}
  \item[a) Property of $\rho$ and constant parameter $u$.] We assume that the
    $\forall e \in \mathcal{R}_{num}, \mathcal{SD}_{\mathbf{num}}(\rho(e), e)
    \leq q$ where $q$ is the grade in the $\mathbf{rnd}$ typing rule.
  \item[b) Property of $\mathbf{op}$.] 
    We can view $\textit{op}$ as a (possibly constant) metalevel function.
    We also assume that for every operation
    $\mathbf{op} : \tau \in \ \Sigma$ we have a
    corresponding function $op$ mapping syntactic values in
    $\mathcal{VR}_{\tau}$ where metric preservation holds: For all $\sigma
    \sim_{\gamma} \sigma' : \Gamma$, $\textit{op}~\sigma \sim_{\gamma \cdot
    \Gamma} \textit{op} : \tau$.
    Or, expanded:
    \begin{description}
      \item[\underline{1) Type denotation.}] $\mathit{op} \in
        \mathcal{R}_{\tau}$. The metalevel operation will step to something in the
        value relation.
      \item[\underline{2) Context sensitivity.}]
        This property states that for every $\textbf{op}$, the
        corresponding $\textit{op}$ preserves the metric. For any two
        substitutions $\sigma, \sigma'$ such that:
        $\sigma \sim_{\gamma} \sigma' : \Gamma$
        we have that
        $\mathcal{SD}_{\tau}(\textit{op}~\sigma, \textit{op}~\sigma') \leq \gamma \cdot \Gamma$.
    \end{description} \item[c) Property of $\mathbf{iop}$.] We further need to
      assume that for every operation $\mathbf{iop}_c : \Sigma_\textbf{num}$, we
      have that for any sequence of bounds $b_0, b_1, \ldots : \textbf{bnd}$ the
      corresponding metalevel function will actually map to a concrete bound
      where $\textit{iop}_c(b_0, b_1, \ldots) : \textbf{bnd} = (k_0, k_1)$
      holds.
\end{description}
\end{definition}

\begin{lemma}[$\mathcal{SD}$ is a metric]
  $\mathcal{SD}$ forms a metric over our syntactic terms; in particular it
  satisfies:
  \begin{enumerate}
    \item Distance from any point to itself is zero: $\forall x,~\mathcal{SD}(x,
      x) = 0$.
    \item Positivity: $\forall x, y,~\mathcal{SD}(x, y) \geq 0$.
    \item Symmetry: $\forall x, y,~\mathcal{SD}(x, y) = \mathcal{SD}(y, x)$.
    \item Triangle inequality: $\forall x, y, z,~\mathcal{SD}(x, z) \leq
      \mathcal{SD}(x, y) + \mathcal{SD}(y, z)$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  The properties holds for the base cases of $\mathcal{SDV}$ and follow for the
  remaining cases by our inductive hypothesis. Since our operational semntics is
  deterministic, the properties follow for $\mathcal{SD}$.
\end{proof}

\begin{lemma}[$\mathcal{SD}$ is preserved under stepping]
  If $e_0 \mapsto e'_0$, then for any $e_1$, $\mathcal{SD}(e_0, e_1) =
  \mathcal{SD}(e'_0, e_1)$.
\end{lemma}
\begin{proof}
  Holds by inspection of the definition of $\mathcal{SD}$.
\end{proof}
Note that by metric symmetry, $\mathcal{SD}$ is preserved under stepping on both
sides.

% probs needs some theorem relating SD to d, what do property do we want to
% enforce here? (probs need to factor out a lemma or something when doing the
% logical relations proof)

