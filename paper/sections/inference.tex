\section{Type inference} \label{sec:inference}
% Similar to our language syntax and semantics, our type inference approach is
% also modular. We parametrize our algorithm by an injection function mapping
% from our concrete domain $\textit{num}$ to intervals: $inj : \textit{num} \to
% \textit{num}^2$. 
% We only constrain $inj$ to be closed:
% \begin{definition}[$inj$ is closed.] \label{def:inj-closed}
% For all $k \in \textit{num}$, $k \in inj(k)$.
% \end{definition}
%
% We also need an abstract transformer $-^{\#}$ lifting operations to operations on
% their abstract domain such that every concrete result possible falls within the
% abstract domain.
%
% % todo: state missing correctness property of our abstract transformer, setup
% % galois connection
%
% \subsection{Problem setup}
Users write programs in \Lang, without sensitivities or bound polymorphism. We
compute the type sensitivity and inference analysis developed in
\cite{numfuzz}, extended to our core language without bound polymorphism.
At the same time, we also automatically infer polymorphic bound annotations to
generate a valid typing derivation of the program in \bnd{\Lang}.
For example, the following unannotated program would be transformed as follows:

\begin{example}[Unannotated example program]
  \begin{equation}
    \lambda x \ . \ \mathbf{let} \ s \ = \ add \ x \ \tin \ (\mathbf{rnd} \ s)
    : \textbf{num} \times \textbf{num} \multimap \textbf{num}
  \end{equation}
\end{example}

\begin{example}[Annotated program]
  \begin{equation}
    \bnd{\Lambda \epsilon_0, \epsilon_1 \ .} \lambda x : num_{\bnd{\epsilon_0}}
    \times num_{\bnd{\epsilon_1}} \ . \ 
    \mathbf{let} \ s \ = \ add \ \bnd{\{\epsilon_0\}} \ \{\bnd{\epsilon_1\}} \ x
    \ \tin \ (\mathbf{rnd} \ s)
    : 
    \bnd{\forall \epsilon_0, \epsilon_1 \ .} \ 
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap
    \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}}
  \end{equation}
\end{example}

\begin{equation}
  \begin{aligned}[c]
    add &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}} \\
    sub &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 - \epsilon_1}} \\
    mult &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 \cdot \epsilon_1}} \\
  \end{aligned}
\end{equation}

To define the type inference problem, we first define two erasure operations
over terms, types and contexts. Full typing contexts can be seen as maps from
variables to pairs of sensitivities and types. We will then define type
inference as inferring sensitivities and bound over erased, well-typed terms.

\begin{definition}[Sensitivity and round-off erasure]
For a fully annotated typing context $\Gamma$, a fully erased typing context
$\Gamma^{\bullet} = \Gamma \circ (map \ \pi_2)$ with all sensitivity and
round-off information erased.
\end{definition}

\begin{definition}[Bound erasure]
We define bound erasure ($-^{\bnd{\bullet}}$) over types and terms below:
\begin{equation}
\begin{aligned}[c]
\textbf{unit}^{\bnd{\bullet}} &\triangleq \textbf{unit} \\
\textbf{num}_i^{\bnd{\bullet}} &\triangleq \textbf{num} \\
(!_s \tau)^{\bnd{\bullet}} &\triangleq !_s \tau^{\bnd{\bullet}} \\
(M_u \tau)^{\bnd{\bullet}} &\triangleq M_u \tau^{\bnd{\bullet}} \\
(\forall \epsilon . \tau)^{\bnd{\bullet}} &\triangleq \tau^{\bnd{\bullet}} \\
(\tau_0 \times \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \times \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \otimes \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \otimes \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \multimap \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \multimap \tau_1^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation}

We similarly define an erasure operation for terms:
\begin{equation}
\begin{aligned}[c]
(e \{ i \})^{\bnd{\bullet}} &\triangleq e  \\
(\Lambda \epsilon . e)^{\bnd{\bullet}} &\triangleq e \\
e^{\bnd{\bullet}} &\triangleq e &\text{otherwise} 
\end{aligned}
\end{equation}
\end{definition}

\begin{definition}[Type inference problem]
Given an erased program $e^{\bnd{\bullet}}$, produce a derivation of $. \vdash e
: \tau$ for $e$ in \Lang if such a derivation exists. 
\end{definition}

\subsection{Subtyping and supertyping}
Before we provide the algorithm, we extend the subtyping and supertyping
relations in Numerical Fuzz. In particular, we add the following cases to
deal with bounds and bound polymoprhism. 
$$
\begin{aligned}[c]
  \textbf{num}_{(k_0, k_1)} \sqsubseteq \textbf{num}_{(k'_0, k'_1)} &\triangleq 
k'_0 \leq k_0 \leq k_1 \leq k'_1 \\
  \textbf{num}_{i} \sqsubseteq \textbf{num}_{i'} &\triangleq \forall i :
  \Delta, \textbf{num}_{i}~[\sigma] \sqsubseteq \textbf{num}_{i'}~[\sigma] \\
  \forall \epsilon_0. \tau \sqsubseteq \forall \epsilon_1. \tau' &\triangleq 
  \forall i : \Delta, \tau~[i/\epsilon_0] \sqsubseteq \tau'~[i/\epsilon_1]
\end{aligned}
$$
the remaining cases are unchanged and listed in Figure~\ref{fig:sub_ty}.

\begin{figure}[htbp]
$$
\begin{aligned}[c]
  \textbf{unit} \sqsubseteq \textbf{unit} \\
\end{aligned}
$$

%% ROW1
\begin{center}
%% CART PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\times$}
\BIC{$ \sigma \times \tau \sqsubseteq \sigma' \times \tau' $}
\DisplayProof
\hskip 2.5em
%% TEN PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\tensor$}
\BIC{$ \sigma \tensor \tau \sqsubseteq \sigma' \tensor \tau' $}
\DisplayProof
\hskip 2.5em
%% SUM
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .+$}
\BIC{$ \sigma + \tau \sqsubseteq \sigma' + \tau' $}
\DisplayProof
\vskip 1em

%% FUN
\AXC{$\sigma' \sqsubseteq \sigma$}
\AXC{$\tau \sqsubseteq \tau' $}
\RightLabel{$\sqsubseteq .\multimap$}
\BIC{$ \sigma \multimap \tau \sqsubseteq \sigma' \multimap \tau' $}
\DisplayProof
\hskip 2.5em
%% MONAD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$u \le u'$}
\RightLabel{$\sqsubseteq .$M}
\BIC{$ \text{M}_u \sigma \sqsubseteq \text{M}_{u'} \sigma' $}
\DisplayProof
\hskip 2.5em
%% BANG
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$s \le s'$}
\RightLabel{$\sqsubseteq .!$}
\BIC{$ \bang{s'} \sigma \sqsubseteq !_{s} \sigma' $}
\DisplayProof

\end{center}
    \caption{The subtype relation in \Lang, with $s,s',u,u' \in \NNR \cup \{\infty\}$. }
    \label{fig:sub_ty}
\end{figure}

\begin{theorem}[Admissibility of subtyping] \label{thm:subtyping}
  The typing judgement $\Delta \ | \ \Gamma \vdash e : \tau$ is derivable if
  $\Delta \ | \ \Gamma \vdash e : \tau'$ has a derivation and $\tau \sqsubseteq
  \tau'$.
\end{theorem}
\begin{proof}
  The admissibility of subtyping mostly follows from the proof in
  \cite{numfuzz}.
  We detail the new cases that are not immediate below:
  \begin{description}
    \item[Case (Widen).] Corresponds to the new \textbf{num} cases we added to
      the subtyping relation. 
    \item[Case $\forall \epsilon_0 . \tau$.] Follows from application of the
      inductive hypothesis.
  \end{description}
  and the new interval widening rule in our type
  system, which corresponds to the $\textbf{num}$ subtyping case. 
  Note that the proof in \cite{numfuzz} relies on
  the admissibility of weakening, which we proved in (Theorem
  \ref{thm:weakening}).
\end{proof}


\subsection{Inference algorithm}
We are now ready to define the type inference algorithm
Our type inference algorithm has the following shape:
$$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$$
where we start a program with a typing context $\Gamma^{\bullet}$ that has
erased sensitivity information (but with bound variables) and an erased program
$e^{\bnd{\bullet}}$ with no polymorphic bounds, and produces a typing context
$\Gamma$ with sensitivity information and fully annotated program e and type
$\tau$ such that
$\Delta \ | \ \Gamma' \vdash e' : \tau$
is derivable for some $\Delta$ (our soundness criterion). We start type
inference by passing the empty context (written .), along with the bound-erased
program (written $e^{\bnd{\bullet}}$) to the inference algorithm detailed in
Figure~\ref{fig:inference-algo}. Finally, we evaluate our lifted interval
operations (if they exist) until they get suck.

Conceptually, our type inference algorithm does three things: 
\begin{enumerate}
  \item We infer sensitivities via the type inference algorithm provided in
    \cite{numfuzz}, extended to deal with our new $\mathbf{factor}$ primitive
    and interval bounds as well as support expressions in greater places.

  \item We infer bounds. During bound inference, we rely on helper functions $I$
    and $E$ (Figure~\label{fig:helper_type_inference}) to automatically
    instantiate and eliminate bound variables.

  \item We compute our interval operations. The output of bound inference may
    produce interval expressions that can be further reduced.
\end{enumerate}
We present our type inference algorithm as a combined algorithm where the
sensitivities and bounds are inferred in one pass:

\begin{figure}\label{fig:inference-algo}
%% ROW1
\begin{center}

\AXC{}
\UIC{$I(\textbf{unit}^{\bnd{\bullet}}) \to \textbf{unit}; .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% \AXC{$\epsilon \not \in FTV(\Gamma) \cup DOM(\Delta)$}
\AXC{$\epsilon \text{ globally fresh}$}
\UIC{$ I(\textbf{num}^{\bnd{\bullet}}) \to \textbf{num}_{\epsilon};
\epsilon $}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \times \tau_1)^{\bnd{\bullet}}) \to \tau_0 \times
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \otimes \tau_1)^{\bnd{\bullet}}) \to \tau_0 \otimes
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 + \tau_1)^{\bnd{\bullet}}) \to \tau_0 + \tau_1; \alpha,
\beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \multimap \tau_1)^{\bnd{\bullet}}) \to \tau_0 \multimap
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau^{\bnd{\bullet}}) \to \tau; \beta$}
\UIC{$I(!_s (\tau^{\bnd{\bullet}})) \to !_s \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau^{\bnd{\bullet}}) \to \tau; \beta$}
\UIC{$I(M_u (\tau^{\bnd{\bullet}})) \to M_u \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\vskip 3em

\AXC{}
\UIC{$E(\textbf{unit}) \to .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{}
\UIC{$E(\textbf{num}_i) \to i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \times \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \otimes \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 + \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0) \to \alpha$}
\AXC{$E(\tau_1) \to \beta$}
\BIC{$E((\tau_0 \multimap \tau_1)) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau) \to \beta$}
\UIC{$E(!_s (\tau)) \to \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau) \to \beta$}
\UIC{$E(M_u (\tau)) \to \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau) \to \beta$}
\UIC{$E(\forall \epsilon. \tau) \to \beta$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Ancillary functions for defining algorithmic type inference.}
    \label{fig:helper_type_inference}
\end{figure}

\newpage

\begin{figure}
\begin{center}
%% unit
\AXC{}
\RightLabel{(Unit)}
\UIC{$\Gamma^{\bullet}; \langle \rangle^{\bnd{\bullet}}; \implies \Gamma^{0};
\langle \rangle; \textbf{unit}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% var
\AXC{}
\RightLabel{(Var)}
\UIC{$\Gamma^{\bullet}, x : \tau, x^{\bnd{\bullet}} \implies \Gamma^{0}, x
:_1 \tau; x; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%% const
\AXC{}
\RightLabel{(Const)}
\UIC{$\Gamma^{\bullet}; k^{\bnd{\bullet}}; \implies \Gamma^{0};
k; \textbf{num}_{\bnd{inj(k)}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% bang intro
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{($!$ I)}
\UIC{$\Gamma^{\bullet}; [e]_{\annotate{s}}^{\bnd{\bullet}} \implies s
* \Gamma'; [e']_{\annotate{s}}; !_s~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% fun
\AXC{$I(\tau_0^{\bnd{\bullet}}) = \annotate{\tau_0}; \epsilon_0, \ldots, \epsilon_n$}
\AXC{$\Gamma^{\bullet}, x : \annotate{\tau_0}; e^{\bnd{\bullet}} \implies \Gamma', x
:_s \annotate{\tau_0}; e'; \tau$}
\AXC{$s \geq 1$}
\RightLabel{($\multimap$ I)}
\TIC{$\Gamma^{\bullet}; \lambda (x : \annotate{\tau_0^{\bnd{\bullet}}}). e^{\bnd{\bullet}}
\implies \Gamma'; \Lambda \epsilon_0, \ldots, \epsilon_n
(\lambda (x : \annotate{\tau_0}) . e'); \forall \epsilon_0, \ldots, \epsilon_n . \
\annotate{\tau_0} \multimap \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% imp elim, forall
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}; f^{\bnd{\bullet}} &\implies \Gamma'; f'; \forall
\epsilon_0, \ldots, \epsilon_n \ . \ \tau_0 \multimap \tau \\
\Gamma^{\bullet}; e^{\bnd{\bullet}} &\implies \Theta; e'; \tau'_0 \\
\end{aligned} $}
\hskip 0.5em
\AXC{$\begin{aligned}[t]
E(\tau'_0) &\to i_0, \ldots, i_n \\
\tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] &\sqsubseteq \tau'_0 \\
\end{aligned}
$}
\RightLabel{($\multimap$ E)}
\BIC{$\Gamma^{\bullet}; (f~e)^{\bnd{\bullet}} \implies \Gamma' +
\Theta; (f'~\{ i_0 \}~\ldots~\{ i_n \})~e'; \tau'$}
\bottomAlignProof
\DisplayProof
\vskip 1em
% todo: evaluating the liftted iops happen after we complete inference

% todo: require that ops are closed at the bound polymorphism level
\RightLabel{(\textbf{op})}
\AXC{$\{\textbf{op} : \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1 \} \in \Sigma$}
\UIC{$\Gamma^{\bullet}; \textbf{op}^{\bnd{\bullet}} \implies \Gamma;
\textbf{op}; \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{factor})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; (M_q
\tau_0 \times M_r \tau_1)$}
\UIC{$\Gamma^{\bullet}; \textbf{factor}~e^{\bnd{\bullet}} \implies
\Gamma'; \textbf{factor}~e'; M_{max(q, r)} (\tau_0 \times \tau_1)$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Structural rules below                            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 1em

%% Ret
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Ret})}
\UIC{$\Gamma^{\bullet}; \textbf{ret}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{ret}~e'; M_0~\tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% Rnd
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Rnd})}
\UIC{$\Gamma^{\bullet}; \textbf{rnd}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{rnd}~e'; M_q~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% times intro 
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_0; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_1; f'; \tau_1$}
\RightLabel{($\times$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}} \implies
\text{max}(\Gamma_0, \Gamma_1); \langle f', e' \rangle; \tau_0 \times \tau_1$}
% todo: check that max is defined
\bottomAlignProof
\DisplayProof
\RightLabel{($\times$ E)}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0
\times \tau_1$}
\UIC{$\Gamma^{\bullet}; (\pi_i~e)^{\bnd{\bullet}} \implies
\Gamma'; \pi_i~e'; \tau_i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% otimes intro 
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_0; f'; \tau_1$}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_1; e'; \tau_0$}
\RightLabel{($\otimes$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}}
\implies \Gamma_0 + \Gamma_1; (f', e'); \tau_0 \otimes \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}, x : \tau_0; f^{\bnd{\bullet}} \implies \Theta, x :_s
\tau_0; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma + \Theta;
\textbf{let} \ x \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-pair})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
\tau_0 \otimes \tau_1$}
\AXC{$\Gamma^{\bullet}, x: \tau_0, y : \tau_1; f^{\bnd{\bullet}}
\implies \Theta, x :_s \tau_0, y :_{s'} \tau_1; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-pair} \ (x, y) \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies max(s, s') \cdot \Gamma' + \Theta;
\textbf{let-pair} \ (x, y) \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-bind})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
M_r~\tau_0$}
\AXC{$\Gamma^{\bullet}, x: \tau_0; f^{\bnd{\bullet}} \implies \Theta, x
:_s \tau_0; f; M_q~\tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-bind} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma' + \Theta;
\textbf{let-bind} \ x \ = \ e' \ \textbf{in} \ f'; M_{s \cdot r + q}~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{case})}
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma; e'; \tau_0 + \tau_1 \\
s > 0
\end{aligned}
$}
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}, x : \tau_0 ; f_1^{\bnd{\bullet}} \implies \Theta_0, x :_s \tau_0; f'_1; \tau_0 \\
\Gamma^{\bullet}, x : \tau_0 ; f_2^{\bnd{\bullet}} \implies \Theta_1, x :_s \tau_0; f'_2; \tau_1
\end{aligned}
$}
\BIC{$\Gamma^{\bullet}; (\textbf{case} \ e \ \textbf{of} \
(\textbf{in}_1~x.f_1 ~ | ~ \textbf{in}_2~x.f_2))^{\bnd{\bullet}}
\implies s \cdot \Gamma + max(\Theta_0, \Theta_1); (\textbf{case} \ e' \ \textbf{of}
\ (\textbf{in}_1~x.f'_1 ~ | ~ \textbf{in}_2~x.f'_2)) ; \text{max}(\tau_0, \tau_1)$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Algorithmic rules. \annotate{Red text} are user-required
    annotations. To help define the $\implies$ relation, we
    define a $\to$ relation that annotates (removes the bullet) for a given
    type.}
    \label{fig:type_inference}
\end{figure}

\begin{lemma}[Elimination between $I$ and $E$.]
Pick some type $\tau$.
Let $\tau'; \epsilon_0, \ldots, \epsilon_n = I(\tau^{\bnd{\bullet}})$.
Let $i_0, \ldots i_n = E(\tau)$.
Then, $\tau = \tau'[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$.
\end{lemma}
\begin{proof}
Holds by induction over types.
\end{proof}

\begin{lemma}[Free vars in $\Gamma$.] \label{thm:free-var-gamma}
  For any typing derivation for some $\Delta \ | \ \Gamma \vdash e : \tau$,
  $FTV(\Gamma) \subseteq \Delta$ and $FTV(\tau) \subseteq \Delta$.
\end{lemma}
\begin{proof}
  By induction over the $\vdash$ relation.
\end{proof}

\begin{lemma}[Free vars in $I$.] \label{thm:free-var-i}
  For any type $\tau$, $I(\tau) = \tau'; \epsilon_0 \cdots \epsilon_n$, we have
  that $FTV(\tau') = \{ \epsilon_0, \cdots, \epsilon_n \}$.
\end{lemma}
\begin{proof}
  By induction over the definition of $I$.
\end{proof}

\begin{lemma}[Well-formedness of intervals produced by $E$.] \label{thm:wff-var-e}
  For any types $\tau$, $E(\tau) \to i_0, \cdots, i_n$ means that for every
  $i_j$, if $FTV(\tau) \subseteq \Delta$ then $\Delta \vdash i_j$.
\end{lemma}
\begin{proof}
  We apply weakening (over bound contexts, Lemma~\ref{thm:weakening-bnd}) to the
  conclusion. So it suffices to prove that $FTV(\tau) \vdash i_j$. We complete
  the proof by induction over $\tau$.
\end{proof}

\begin{theorem}[Algorithmic Soundness] \label{thm:algo-soundness}
If $\Gamma^{\bullet}; e^{\bullet} \implies \Gamma'; e'; \tau'$ then there is
some $\Delta$ such that $\Delta \ | \ \Gamma' \vdash e' : \tau$ has a typing
derivation where $\Gamma^{\bullet} = \Gamma'^{\bullet}$ and $e^{\bnd{\bullet}} =
e'^{\bnd{\bullet}}$.
\end{theorem}
\begin{proof}
We induct over each typing / case in the type inference algorithm. 
\begin{description}
  \item[$\textbf{unit}$.] Holds trivially.
  \item[Var.] Holds trivially.
  \item[Const.] Holds trivially. 
  \item[! I.] Holds trivially.
  \item[$\multimap$ I.] By our inductive hypothesis, we know that there exists a
    $\Delta'$ such that we have a typing derivation $d$ for 
    $\Delta' \ | \ \Gamma', x:_s \tau_0 \vdash e' : \tau$. 
    We wish for each $\epsilon_0, \cdots , \epsilon_n$ to apply our
    $\forall I$ rule to $d$. 
    \par\bigskip

    For all $i$ (each application), we must satisfy that
    (1) $\epsilon_i \in \Delta'$ and (2) $\epsilon_i \not\in FTV(\Gamma)$.
    Let $\Delta = FTV(\tau_0) = \{\epsilon_0, \cdots, \epsilon_n\}$ by
    Lemma~\ref{thm:free-var-i}. 
    Then, we have that $\Delta \subseteq \Delta'$ by
    Lemma~\ref{thm:free-var-gamma} and therefore each $\epsilon_0, \cdots,
    \epsilon_n \not\in \Delta'$.
    We further have that $FTV(\Gamma) \cap \Delta = \emptyset$ as $I$ only
    generates fresh vars. 
    So both of our two conditions have been satisifed.
  \item[$\multimap$ E.] By our inductive hypothesis, we know that there exist
    derivations:
    \begin{itemize}
      \item $d_0$ where $\Delta' \ | \ \Gamma' \vdash f : \forall
        \epsilon_0, \cdots, \epsilon_n, \tau_0 \multimap \tau$
      \item $d_1$ where $\Delta'' \ | \ \Theta \vdash e : \tau_0'$
    \end{itemize}
    Note that $\epsilon_0, \cdots, \epsilon_n$ are fresh from $\Delta''$ as each
    $\epsilon$ generated is globally fresh in our type inference algo.
    \par\bigskip

    By weakening on our inductive hypothesis, we have a derivation for $\Delta \
    | \ \Theta \vdash e : \tau_0[\epsilon_0 / i_0, \cdots, \epsilon_n / i_n]$
    (think contrapositively for now). 
    Then we are able to
    iteratively apply the $\forall E$ typing rule to our derivation $d$ for each
    $\epsilon_0, \cdots, \epsilon_n$, obtaining
    us the following intermediate typing derivation $d_3$: 
    $\Delta' - \{\epsilon_0, \cdots, \epsilon_n\} \cup \Delta'' \ | \ \Gamma'
    \vdash f' \ \{i_0\} \cdots \{i_n\} : \tau_0 \multimap \tau$.
    \par\bigskip

    Note that the $\Delta \vdash i : \textbf{bnd}$ condition in each application
    of the $\forall E$ rule is satisfied by applying Lemma~\ref{thm:wff-var-e}
    and Lemma~\ref{thm:free-var-gamma} on the interval bound judgements.
    In particular, by Lemma~\ref{thm:free-var-gamma}, we have that $FTV(\tau'_0)
    \subseteq FTV(\Theta) \subseteq \Delta''$. Applying
    Lemma~\ref{thm:free-var-gamma} and our inductive hypothesis finishes the
    proof obligation.
    Now we are ready to apply our $\multimap E$ typing rule with derivation
    $d_1$ to obtain a dervation for: $\Delta' \cup \Delta'' \vdash (f' \ \{i_0\}
    \cdots \{i_n\}) e' : \tau'$ which completes the case.
  \item[Op.] Holds trivially.
  \item[Factor.] Holds trivially.
  \item[Ret.] Holds trivially.
  \item[Rnd.] Holds trivially.
  \item[$\times$ I.] Like Numerical Fuzz, we define \text{max} as the least
    upper bound of $\Gamma_0$ and $\Gamma_1$. Let $\Delta_0$ and $\Delta_1$ be
    the (implicit) interval bound contexts generated by our inductive
    hypothesis.
    By weakening, we can produce a typing derivation for the following
    judgement:
    $\Delta_0 \cup \Delta_1 \ | \ \text{max}(\Gamma_0, \Gamma_1) \vdash \langle
    f', e' \rangle; \tau_0 \times \tau_1$ which completes the case.
  \item[$\times$ E.] Holds trivially.
  \item[$\times$ E.] Holds trivially.
  \item[$\otimes$ I.] Holds trivially.
  \item[Let.] Holds trivially.
  \item[Let-pair.] Holds by weakening to the second inductive hypothesis to
    obtain a derivation $\Delta \ | \ \Gamma, x :_{\text{max}(s, s')} \tau_0, y
    :_{\text{max}(s, s')} \tau_1 \vdash f' : \tau$ and applying the
    corresponding $\times E$ rule to complete the case.
  \item[Let-bind.] Holds trivially.
  \item[$\otimes$ E.] By the definition of $\text{max}$, we have that 
    $\tau_0 \subseteq \text{max}(\tau_0, \tau_1)$
    and
    $\tau_1 \subseteq \text{max}(\tau_0, \tau_1)$.
    
    Applying the admissibility of subtyping (Theorem~\label{ref}) to our inductive
    hypothesis, we obtain: 
    $\Delta_0 \ | \ \Theta_0 x :_s \tau_0 \vdash f'_1 : \text{max}(\tau_0, \tau_1)$
    and
    $\Delta_1 \ | \ \Theta_1 x :_s \tau_1 \vdash f'_2 : \text{max}(\tau_0, \tau_1)$.
    We can now finish by applying our $\otimes$ E typing rule which completes
    the case.
\end{description}
\end{proof}

% \subsection{Tightness} \label{sec:tightness}
% A natural question to ask is whether the paired representation introduced in the
% proceeding section leads to looser error bounds on programs that could have been
% typed using the standard, unpaired representation. In the following section, we
% demonstrate that for the programs obtained using the unpaired representation in
% Numerical Fuzz, our bounds inferred through type inference and obtained through
% our paired representation are no looser.
%
% To demonstrate this, we instantiate our language with the following interface
% $(\mathbb{P}^{+}, d, \rho_{\mathbb{P}}, u, \Sigma = \{ \mathbf{add},
% \mathbf{mul} \}, \Sigma_{\mathbf{num}})$, where 
% $\mathbb{P}^+ = \{(r, r, 0) \ | \ \forall r \in \mathbb{R}^{+} \}$ 
% and 
% $d((r, a, b), (r', a', b')) = d_{\mathbb{R}}(r, r')$.
% Note that we do not modify our modular type inference algorithm and leave the
% instantiation the same.
% Let us write programs derivable in this type system using the
% $\vdash_{\mathbb{R}}$ judgement and $\vdash_{\mathbb{P}}$ for the
% paired representation instantiated previously. % todo: add backref
% We observe that programs step the same in both instantiations of the language
% and also that programs derivable in $\vdash_{\mathbb{R}}$ have the same type
% with $\vdash_{\mathbb{P}}$:
% \begin{lemma}[Derivablity]
% If $\Delta \ | \ \Gamma \vdash_{\mathbb{R}} e : \tau$,
% then
% $\Delta \ | \ \Gamma \vdash_{\mathbb{P}} e : \tau$ 
% \end{lemma}
% \begin{proof}
%   Proof by induction. $\vdash_{\mathbb{R}}$ has strictly less operations and the
%   associated rounding functions $\rho_{\mathbb{P}}$ and $u$ bounds are the same.
% \end{proof}
%
% We also observe that for a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, $q$ suffices to bound the
% maximum permitted round-off error.
%
% \begin{theorem}[Unpaired error soundness theorem]
% For a program $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we have that $ e \mapsto^{*} ((r, a,
% b), (r', a', b'))$ where $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Holds by applying our metric preservation theorem and unfolding our logical
%   relation and error metric.
% \end{proof}
%
% We are now ready to state our tightness theorem which guarantees that the paired
% representation produced error bounds no looser than the unpaired representation.
%
% \begin{lemma}[Tightness type inference lemma]\label{thm:tightness-helper}
%   If $b$ is always zero in our concrete domain and our program does not contain
%   subtraction, our type inference algorithm always infers that $b^{\uparrow} =
%   b^{\downarrow} = 0$.
% \end{lemma}
% \begin{proof}
%   We track all the intervals produced by the type inference algorithm. Intervals
%   are produced by $inj$ (base case) or by applying our lifted operations $op^{\#}$ (inductive case).
%   By induction, in both cases, our invariant $b^{\uparrow} = b^{\downarrow} =
%   0$ holds.
% \end{proof}
%
% \begin{theorem}[Tightness]
% For a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we know that $. \vdash e
% :  M_q \mathbf{num}_i$ and $e \mapsto^{*} ((r, a, b), (r', a', b'))$ where 
% $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Unfold our logical relation and error metric. Note that our underlying carrier
%   set of $\mathbb{P}$ is zeroed out in the last component. By
%   Lemma~\ref{thm:tightness-helper}, we know that our type inference algorithm
%   will produce $b = b^{\uparrow} = b^{\downarrow} = 0$. 
%   By applying our a priori error theorem
%   (Theorem~\ref{thm:paired-a-priori-rel}), we have our terms neatly zero out and
%   simplify such that $d_{\mathbb{R}}(r, r') = ln(e^q) = q$.
% \end{proof}

% TODO: clarify how to start / use interval analysis, stitch together theorems
