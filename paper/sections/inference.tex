\section{Type inference} \label{sec:inference}
Similar to our language syntax and semantics, our type inference approach is
also modular. We parametrize our algorithm by an injection function mapping
from our concrete domain $\textit{num}$ to intervals: $inj : \textit{num} \to
\textit{num}^2$. 
We only constrain $inj$ to be closed:
\begin{definition}[$inj$ is closed.] \label{def:inj-closed}
For all $k \in \textit{num}$, $k \in inj(k)$.
\end{definition}

We also need an abstract transformer $-^{\#}$ lifting operations to operations on
their abstract domain such that every concrete result possible falls within the
abstract domain.

% todo: state missing correctness property of our abstract transformer, setup
% galois connection

\subsection{Problem setup}
Conceptually, we can think of our type inference algorithm in two
stages. Users write programs in \Lang, without sensitivities or bound polymorphism. We then perform the type sensitivity and
inference algorithm developed in \cite{numfuzz}, extended to our core language
without bound polymorphism. Finally, we automatically infer polymorphic bound
annotations to generate a valid typing derivation of the program in \bnd{\Lang}.
For example, the following unannotated program would be transformed as follows:

\begin{example}[Unannotated example program]
  \begin{equation}
    \lambda x \ . \ \mathbf{let} \ s \ = \ add \ x \ \tin \ (\mathbf{rnd} \ s)
    : \textbf{num} \times \textbf{num} \multimap \textbf{num}
  \end{equation}
\end{example}

\begin{example}[Annotated program]
  \begin{equation}
    \bnd{\Lambda \epsilon_0, \epsilon_1 \ .} \lambda x : num_{\bnd{\epsilon_0}}
    \times num_{\bnd{\epsilon_1}} \ . \ 
    \mathbf{let} \ s \ = \ add \ \bnd{\{\epsilon_0\}} \ \{\bnd{\epsilon_1\}} \ x
    \ \tin \ (\mathbf{rnd} \ s)
    : 
    \bnd{\forall \epsilon_0, \epsilon_1 \ .} \ 
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap
    \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}}
  \end{equation}
\end{example}

\begin{equation}
  \begin{aligned}[c]
    add &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 + \epsilon_1}} \\
    sub &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 - \epsilon_1}} \\
    mult &: \bnd{\forall \epsilon_0, \epsilon_1 \ .} \
    \textbf{num}_{\bnd{\epsilon_0}} \times \textbf{num}_{\bnd{\epsilon_1}}
    \multimap \textbf{num}_{\bnd{\epsilon_0 \cdot \epsilon_1}} \\
  \end{aligned}
\end{equation}

To define the type inference problem, we first define two erasure operations
over terms, types and contexts. Full typing contexts can be seen as maps from
variables to pairs of sensitivities and types. We will then define type
inference as inferring sensitivities and bound over erased, well-typed terms.

\begin{definition}[Sensitivity and round-off erasure]
For a fully annotated typing context $\Gamma$, a fully erased typing context
$\Gamma^{\bullet} = \Gamma \circ (map \ \pi_2)$ with all sensitivity and
round-off information erased.
\end{definition}

\begin{definition}[Bound erasure]
We define bound erasure ($-^{\bnd{\bullet}}$) over types and terms below:
\begin{equation}
\begin{aligned}[c]
\textbf{unit}^{\bnd{\bullet}} &\triangleq \textbf{unit} \\
\textbf{num}_i^{\bnd{\bullet}} &\triangleq \textbf{num} \\
(!_s \tau)^{\bnd{\bullet}} &\triangleq !_s \tau^{\bnd{\bullet}} \\
(M_u \tau)^{\bnd{\bullet}} &\triangleq M_u \tau^{\bnd{\bullet}} \\
(\forall \epsilon . \tau)^{\bnd{\bullet}} &\triangleq \tau^{\bnd{\bullet}} \\
(\tau_0 \times \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \times \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \otimes \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \otimes \tau_1^{\bnd{\bullet}}) \\
(\tau_0 \multimap \tau_1)^{\bnd{\bullet}} &\triangleq (\tau_0^{\bnd{\bullet}} \multimap \tau_1^{\bnd{\bullet}}) \\
\end{aligned}
\end{equation}

We similarly define an erasure operation for terms:
\begin{equation}
\begin{aligned}[c]
(e \{ i \})^{\bnd{\bullet}} &\triangleq e  \\
(\Lambda \epsilon . e)^{\bnd{\bullet}} &\triangleq e \\
e^{\bnd{\bullet}} &\triangleq e &\text{otherwise} 
\end{aligned}
\end{equation}
\end{definition}

\begin{definition}[Type inference problem]
Given an erased program $e^{\bnd{\bullet}}$, produce a derivation of $. \vdash e
: \tau$ for $e$ in \Lang if such a derivation exists. 
\end{definition}

\subsection{Subtyping and supertyping}
Before we provide the algorithm, we extend the subtyping and supertyping
relations in Numerical Fuzz. In particular, we add the following cases to
deal with bounds and bound polymoprhism. 
$$
\begin{aligned}[c]
  \textbf{num}_{(k_0, k_1)} \sqsubseteq \textbf{num}_{(k'_0, k'_1)} &\triangleq 
k'_0 \leq k_0 \leq k_1 \leq k'_1 \\
  \textbf{num}_{i} \sqsubseteq \textbf{num}_{i'} &\triangleq \forall i :
  \Delta, \textbf{num}_{i}~[\sigma] \sqsubseteq \textbf{num}_{i'}~[\sigma] \\
  \forall \epsilon_0. \tau \sqsubseteq \forall \epsilon_1. \tau' &\triangleq 
  \forall i : \Delta, \tau~[i/\epsilon_0] \sqsubseteq \tau'~[i/\epsilon_1]
\end{aligned}
$$
the remaining cases are unchanged and listed in Figure~\ref{fig:sub_ty}.

\begin{figure}[htbp]
$$
\begin{aligned}[c]
  \textbf{unit} \sqsubseteq \textbf{unit} \\
\end{aligned}
$$

%% ROW1
\begin{center}
%% CART PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\times$}
\BIC{$ \sigma \times \tau \sqsubseteq \sigma' \times \tau' $}
\DisplayProof
\hskip 2.5em
%% TEN PROD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .\tensor$}
\BIC{$ \sigma \tensor \tau \sqsubseteq \sigma' \tensor \tau' $}
\DisplayProof
\hskip 2.5em
%% SUM
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$\tau \sqsubseteq \tau'$}
\RightLabel{$\sqsubseteq .+$}
\BIC{$ \sigma + \tau \sqsubseteq \sigma' + \tau' $}
\DisplayProof
\vskip 1em

%% FUN
\AXC{$\sigma' \sqsubseteq \sigma$}
\AXC{$\tau \sqsubseteq \tau' $}
\RightLabel{$\sqsubseteq .\multimap$}
\BIC{$ \sigma \multimap \tau \sqsubseteq \sigma' \multimap \tau' $}
\DisplayProof
\hskip 2.5em
%% MONAD
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$u \le u'$}
\RightLabel{$\sqsubseteq .$M}
\BIC{$ \text{M}_u \sigma \sqsubseteq \text{M}_{u'} \sigma' $}
\DisplayProof
\hskip 2.5em
%% BANG
\AXC{$\sigma \sqsubseteq \sigma'$}
\AXC{$s \le s'$}
\RightLabel{$\sqsubseteq .!$}
\BIC{$ \bang{s'} \sigma \sqsubseteq !_{s} \sigma' $}
\DisplayProof

\end{center}
    \caption{The subtype relation in \Lang, with $s,s',u,u' \in \NNR \cup \{\infty\}$. }
    \label{fig:sub_ty}
\end{figure}

\begin{theorem}[Admissibility of subtyping]
  The typing judgement $\Delta \ | \ \Gamma \vdash e : \tau$ is derivable if
  $\Delta \ | \ \Gamma \vdash e : \tau'$ has a derivation and $\tau \sqsubseteq
  \tau'$.
\end{theorem}
\begin{proof}
  The admissibility of subtyping mostly follows from the proof in
  \cite{numfuzz}.
  We detail the new cases that are not immediate below:
  \begin{description}
    \item[Case (Widen).] Corresponds to the new \textbf{num} cases we added to
      the subtyping relation. 
    \item[Case $\forall \epsilon_0 . \tau$.] Follows from application of the
      inductive hypothesis.
  \end{description}
  and the new interval widening rule in our type
  system, which corresponds to the $\textbf{num}$ subtyping case. 
  Note that the proof in \cite{numfuzz} relies on
  the admissibility of weakening, which we proved in (Theorem
  \ref{thm:weakening}).
\end{proof}


\subsection{Inference algorithm}
We are now ready to define the type inference algorithm
Our type inference algorithm has the following shape:
$$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$$
where we start a program with a typing context $\Gamma^{\bullet}$ that has
erased sensitivity information (but with bound variables) and an erased program
$e^{\bnd{\bullet}}$ with no polymorphic bounds, and produces a typing context
$\Gamma$ with sensitivity information and fully annotated program e and type
$\tau$ such that
$\Delta \ | \ \Gamma' \vdash e' : \tau$
is derivable for some $\Delta$ (our soundness criterion). We start type
inference by passing the empty context (written .), along with the bound-erased
program (written $e^{\bnd{\bullet}}$) to the inference algorithm detailed in
Figure~\ref{fig:inference-algo}. Finally, we evaluate our lifted interval
operations (if they exist) until they get suck.

Our type inference algorithm occurs in three stages, starting from an erased
program (with no $\Lambda$ or polymoprhic instantiations) and sensitivity erased
typing context $\Gamma^{\bullet}$:
\begin{enumerate}
  \item We infer sensitivities via the type inference algorithm provided in
    \cite{numfuzz}, extended to deal with our new $\mathbf{factor}$ primitive
    and interval bounds (Section~\ref{sec:sen-type-infer}). $$\Gamma^{\bullet};
    e^{\bnd{\bullet}} \underset{sens.}{\implies} \Gamma; e^{\bnd{\bullet}};
    \tau^{\bnd{\bullet}}$$

  \item We infer bounds. During bound inference, we rely on helper functions $I$
    and $E$ (Figure~\label{fig:helper_type_inference}) to automatically
    instantiate and eliminate bound variables.

  \item We compute our interval operations. The output of bound inference may
    produce interval expressions that can be further reduced.
\end{enumerate}
The full type inference algorithm is $\implies \triangleq
\underset{bnd.}{\implies} \circ \underset{sens.}{\implies}$, throwing away the
intermediate $\tau'$. The construction is detailed below.

\subsubsection{Stage 1/2: Sensitivity and round-off inference}
\label{sec:sen-type-infer}
Our sensitivity inference algorithm extends the inference algorithm presented in
\cite{numfuzz} with the following case for \textbf{factor}
(Figure~\ref{fig:factor-type-infer}).

\begin{figure} 
\begin{center}
\RightLabel{(\textbf{factor})}
\AXC{$\Gamma^{\bullet}; e \underset{sens.}{\implies} \Gamma;
e^{\bnd{\bullet}}; (M_q~\tau_0 \times M_r~\tau_1)^{\bnd{\bullet}}$}
\UIC{$\Gamma^{\bullet}; \mathbf{factor}~e^{\bnd{\bullet}} \underset{sens.}{\implies}
\Gamma; \mathbf{factor}~e^{\bnd{\bullet}};
M_{max(q,r)}~(\tau_0 \times \tau_1)^{\bnd{\bullet}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\end{center}
    \caption{Rule for factor sensitivity inference. Note that $q,r$ are concrete
    numbers so $max(q,r)$ is a concrete, computable number as well.}
    \label{fig:factor-type-infer}
\end{figure}

\subsubsection{Stage 2/2: Bound inference} \label{sec:bnd-type-infer}
The goal of this stage of type inference, then, is to take a program
$e^{\bnd{\bullet}}$ in context $\Gamma$ and produce a program and with type in
context, possibly using bound polymorphism.

\begin{figure}\label{fig:inference-algo}
%% ROW1
\begin{center}

\AXC{}
\UIC{$I(\textbf{unit}^{\bnd{\bullet}}, \Delta) \to \textbf{unit}; .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% \AXC{$\epsilon \not \in FTV(\Gamma) \cup DOM(\Delta)$}
\AXC{$\epsilon \text{ globally fresh}$}
\UIC{$ I(\textbf{num}^{\bnd{\bullet}}, \Delta) \to \textbf{num}_{\epsilon};
\epsilon $}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}},\Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \times \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \times
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \otimes \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \otimes
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 + \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 + \tau_1; \alpha,
\beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau_0^{\bnd{\bullet}}, \Delta) \to \tau_0; \alpha$}
\AXC{$I(\tau_1^{\bnd{\bullet}}, \Delta) \to \tau_1; \beta$}
\BIC{$I((\tau_0 \multimap \tau_1)^{\bnd{\bullet}}, \Delta) \to \tau_0 \multimap
\tau_1; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$I(\tau^{\bnd{\bullet}}, \Delta) \to \tau; \beta$}
\UIC{$I(!_s (\tau^{\bnd{\bullet}}), \Delta) \to !_s \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$I(\tau^{\bnd{\bullet}}, \Delta) \to \tau; \beta$}
\UIC{$I(M_u (\tau^{\bnd{\bullet}}), \Delta) \to M_u \tau ; \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\vskip 3em

\AXC{}
\UIC{$E(\textbf{unit}, \Delta) \to .$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$\Delta \vdash i$}
\UIC{$E(\textbf{num}_i) \to \Delta; i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \times \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \otimes \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 + \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau_0, \Delta) \to \alpha$}
\AXC{$E(\tau_1, \Delta) \to \beta$}
\BIC{$E((\tau_0 \multimap \tau_1), \Delta) \to \alpha, \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\tau, \Delta) \to \beta$}
\UIC{$E(!_s (\tau), \Delta) \to \beta$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$E(\tau, \Delta) \to \beta$}
\UIC{$E(M_u (\tau), \Delta) \to \beta$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$E(\forall \epsilon. \tau) \to \Delta; \beta$}
\UIC{$E(!_s (\tau), \Delta) \to (\Delta - \epsilon); \beta$}
\bottomAlignProof
\DisplayProof
% \hskip 0.5em
% \AXC{$E(\tau, \Delta) \to \beta$}
% \UIC{$E(M_u (\tau), \Delta) \to \beta$}
% \bottomAlignProof
% \DisplayProof
\end{center}
    \caption{Ancillary functions for defining algorithmic type inference.}
    \label{fig:helper_type_inference}
\end{figure}

\newpage

\begin{figure}
\begin{center}
%% unit
\AXC{}
\RightLabel{(Unit)}
\UIC{$\Gamma^{\bullet}; \langle \rangle^{\bnd{\bullet}}; \implies \Gamma^{0};
\langle \rangle; \textbf{unit}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% var
\AXC{}
\RightLabel{(Var)}
\UIC{$\Gamma^{\bullet}, x : \tau, x^{\bnd{\bullet}} \implies \Gamma^{0}, x
:_1 \tau; x; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%% const
\AXC{}
\RightLabel{(Const)}
\UIC{$\Gamma^{\bullet}; k^{\bnd{\bullet}}; \implies \Gamma^{0};
k; \textbf{num}_{\bnd{inj(k)}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% bang intro
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{($!$ I)}
\UIC{$\Gamma^{\bullet}; [e]_{\annotate{s}}^{\bnd{\bullet}} \implies s
* \Gamma'; [e']_{\annotate{s}}; !_s~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% fun
\AXC{$I(\tau_0^{\bnd{\bullet}}) = \annotate{\tau_0}; \epsilon_0, \ldots, \epsilon_n$}
\AXC{$\Gamma^{\bullet}, x : \annotate{\tau_0}; e^{\bnd{\bullet}} \implies \Gamma', x
:_s \annotate{\tau_0}; e'; \tau$}
\AXC{$s \geq 1$}
% \AXC{$\epsilon_0, \ldots, \epsilon_n \not\in FTV(\Gamma) \cup DOM(\Delta)$}
\RightLabel{($\multimap$ I)}
\TIC{$\Gamma^{\bullet}; \lambda (x : \annotate{\tau_0^{\bnd{\bullet}}}). e^{\bnd{\bullet}}
\implies \Gamma'; \Lambda \epsilon_0, \ldots, \epsilon_n
(\lambda (x : \annotate{\tau_0}) . e'); \forall \epsilon_0, \ldots, \epsilon_n . \
\annotate{\tau_0} \multimap \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

% %% imp elim
% \AXC{$\Delta \ | \ \Gamma^{\bullet}; f^{\bullet} \implies \Delta'_0 \ | \ \Gamma_0; f; \tau_0 \multimap \tau$}
% \AXC{$\Delta \ | \ \Gamma^{\bullet}; e^{\bullet} \implies \Delta'_1 \ | \ \Gamma_1; e; \tau'_0$}
% \AXC{$\tau'_0 \sqsubseteq \tau_0$}
% \RightLabel{($\multimap$ E)}
% \TIC{$\Delta \ | \ \Gamma^{\bullet}; f^{\bullet}~e^{\bullet} \implies \Delta_0 +
% \Delta_1 \ | \ \Gamma_0 + \Gamma_1 ; f~e; \tau$}
% \bottomAlignProof
% \DisplayProof
% \vskip 1em

%% imp elim, forall
\AXC{$
\begin{aligned}[t]
\Gamma^{\bullet}; f^{\bnd{\bullet}} &\implies \Gamma'; f'; \forall
\epsilon_0, \ldots, \epsilon_n \ . \ \tau_0 \multimap \tau \\
\Gamma^{\bullet}; e^{\bnd{\bullet}} &\implies \Theta; e'; \tau'_0 \\
\end{aligned} $}
\hskip 0.5em
\AXC{$\begin{aligned}[t]
E(\tau'_0) &\to \Delta; i_0, \ldots, i_n \\
\tau'_0 &\sqsubseteq \tau_0[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] \\
\end{aligned}
$}
% \AXC{$
% \begin{aligned}[t]
% \tau[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n] &\mapsto^{*} \tau' \\
% \tau' &\not\mapsto 
% \end{aligned}
% $}
\RightLabel{($\multimap$ E)}
\BIC{$\Gamma^{\bullet}; (f~e)^{\bnd{\bullet}} \implies \Gamma' +
\Theta; (f'~\{ i_0 \}~\ldots~\{ i_n \})~e'; \tau'$}
\bottomAlignProof
\DisplayProof
\vskip 1em
% todo: evaluating the liftted iops happen after we complete inference

% todo: require that ops are closed at the bound polymorphism level
\RightLabel{(\textbf{op})}
\AXC{$\{\textbf{op} : \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1 \} \in \Sigma$}
\UIC{$\Gamma^{\bullet}; \textbf{op}^{\bnd{\bullet}} \implies \Gamma;
\textbf{op}; \forall \epsilon_0, \epsilon_1, \tau_0 \multimap \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{factor})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; (M_q
\tau_0 \times M_r \tau_1)$}
\UIC{$\Gamma^{\bullet}; \textbf{factor}~e^{\bnd{\bullet}} \implies
\Gamma'; \textbf{factor}~e'; M_{max(q, r)} (\tau_0 \times \tau_1)$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Structural rules below                            %% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vskip 1em

%% Ret
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Ret})}
\UIC{$\Gamma^{\bullet}; \textbf{ret}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{ret}~e'; M_0~\tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% Rnd
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau$}
\RightLabel{(\textbf{Rnd})}
\UIC{$\Gamma^{\bullet}; \textbf{rnd}~e^{\bnd{\bullet}} \implies \Gamma';
\textbf{rnd}~e'; M_q~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% times intro 
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_0; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_1; f'; \tau_1$}
% \AXC{$
% \begin{aligned}[t]
% \Delta'_0 \sqsubseteq \Delta' \\
% \Delta'_1 \sqsubseteq \Delta' \\
% \end{aligned}
% $}
% \AXC{$
% \begin{aligned}[t]
% \Gamma'_0 \sqsubseteq \Gamma' \\
% \Gamma'_1 \sqsubseteq \Gamma' \\
% \end{aligned}
% $}
\RightLabel{($\times$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}} \implies
\text{max}(\Gamma_0, \Gamma_1); \langle f', e' \rangle; \tau_0 \times \tau_1$}
% todo: check that max is defined
\bottomAlignProof
\DisplayProof
\RightLabel{($\times$ E)}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0
\times \tau_1$}
\UIC{$\Gamma^{\bullet}; (\pi_i~e)^{\bnd{\bullet}} \implies
\Gamma'; \pi_i~e'; \tau_i$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% otimes intro 
\AXC{$\Gamma^{\bullet}; f^{\bnd{\bullet}} \implies \Gamma_0; f'; \tau_1$}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma_1; e'; \tau_0$}
\RightLabel{($\otimes$ I)}
\BIC{$\Gamma^{\bullet}; \langle f, e \rangle^{\bnd{\bullet}}
\implies \Gamma_0 + \Gamma_1; (f', e'); \tau_0 \otimes \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e'; \tau_0$}
\AXC{$\Gamma^{\bullet}, x : \tau_0; f^{\bnd{\bullet}} \implies \Theta, x :_s
\tau_0; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma + \Theta;
\textbf{let} \ x \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-pair})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
\tau_0 \otimes \tau_1$}
\AXC{$\Gamma^{\bullet}, x: \tau_0, y : \tau_1; f^{\bnd{\bullet}}
\implies \Theta, x :_s \tau_0, y :_s' \tau_1; f'; \tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-pair} \ (x, y) \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies max(s, s') \cdot \Gamma' + \Theta;
\textbf{let-pair} \ (x, y) \ = \ e' \ \textbf{in} \ f'; \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{let-bind})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma'; e';
M_r~\tau_0$}
\AXC{$\Gamma^{\bullet}, x: \tau_0; f^{\bnd{\bullet}} \implies \Theta, x
:_s \tau_0; f; M_q~\tau$}
\BIC{$\Gamma^{\bullet}; (\textbf{let-bind} \ x \ = \ e \ \textbf{in} \
f)^{\bnd{\bullet}} \implies s \cdot \Gamma' + \Theta;
\textbf{let-bind} \ x \ = \ e' \ \textbf{in} \ f'; M_{s \cdot r + q}~\tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\RightLabel{(\textbf{case})}
\AXC{$\Gamma^{\bullet}; e^{\bnd{\bullet}} \implies \Gamma; e'; \tau_0 +
\tau_1$}
\AXC{$\Gamma^{\bullet}, x : \tau_0 ; f_1^{\bnd{\bullet}}
\implies \Theta_0, x :_s \tau_0; f'_1; \tau_0$}
\AXC{$\Gamma^{\bullet}, x : \tau_0 ; f_2^{\bnd{\bullet}}
\implies \Theta_1, x :_s \tau_0; f'_2; \tau_1$}
\AXC{$s > 0$}
\QIC{$\Gamma^{\bullet}; (\textbf{case} \ e \ \textbf{of} \
(\textbf{in}_1~x.f_1 ~ | ~ \textbf{in}_2~x.f_2))^{\bnd{\bullet}}
\implies s \cdot \Gamma + max(\Theta_0, \Theta_1); (\textbf{case} \ e' \ \textbf{of}
\ (\textbf{in}_1~x.f'_1 ~ | ~ \textbf{in}_2~x.f'_2)) ; \text{max}(\tau_0, \tau_1)$}
\bottomAlignProof
\DisplayProof
\end{center}
    \caption{Algorithmic rules. \annotate{Red text} are user-required
    annotations. To help define the $\implies$ relation, we
    define a $\to$ relation that annotates (removes the bullet) for a given
    type.}
    \label{fig:type_inference}
\end{figure}

\begin{lemma}[Elimination between $I$ and $E$.]
Pick some type $\tau$.
Let $\tau'; \epsilon_0, \ldots, \epsilon_n = I(\tau^{\bnd{\bullet}})$.
Let $i_0, \ldots i_n = E(\tau)$.
Then, $\tau = \tau'[\epsilon_0 / i_0, \ldots, \epsilon_n / i_n]$.
\end{lemma}
\begin{proof}
Holds by induction over types.
\end{proof}

\begin{theorem}[Algorithmic Soundness] \label{thm:algo-soundness}
If $\Gamma^{\bullet}; e^{\bullet} \implies \Gamma'; e'; \tau'$ then there is some
$\Delta$ such that $\Delta \ | \ \Gamma \vdash e' : \tau$ has a typing derivation.
\end{theorem}
\begin{proof}
Note that the full algorithm is the fused combination of the
$\underset{bnd.}{\implies}$ and $\underset{sens.}{\implies}$ algorithms. For
example, the var case for the full algorithm looks like (throwing away the
intermediate $\tau$):
\begin{equation}
\frac
{}
{(\Gamma^{\bullet}, x : \tau); x^{\bnd{\bullet}} \underset{sens.}{\implies}
(\Gamma^0, x :_1 \tau); x^{\bnd{\bullet}}; \tau \underset{bnd.}{\implies}
(\Gamma^{0}, x :_1 \tau); x; \tau}
\end{equation}
We induct over each typing / case in the full algorithm. Many of the cases that
follow from the soundness proof for $\underset{sens.}{\implies}$
(in~\cite{numfuzz}), We detail the cases for which $\underset{bnd.}{\implies}$
is non-structural below:
\begin{description}
  \item[Const.] Holds by our interface for $inj$ from
    Definition~\ref{def:inj-closed}. 
  \item[$\textbf{unit}$.] Holds trivially.
  \item[Var.] Holds trivially.
  \item[$\multimap$ I.] Apply $\forall-I$ for every free $\epsilon$.
  \item[$\multimap$ E.] Apply $\forall-E$ for every bound $\epsilon$.
  \item[$\textbf{op}$.] Holds trivially.
  \item[$\textbf{factor}$.] Holds by application of the inductive hypothesis.
\end{description}
\end{proof}

% \subsection{Tightness} \label{sec:tightness}
% A natural question to ask is whether the paired representation introduced in the
% proceeding section leads to looser error bounds on programs that could have been
% typed using the standard, unpaired representation. In the following section, we
% demonstrate that for the programs obtained using the unpaired representation in
% Numerical Fuzz, our bounds inferred through type inference and obtained through
% our paired representation are no looser.
%
% To demonstrate this, we instantiate our language with the following interface
% $(\mathbb{P}^{+}, d, \rho_{\mathbb{P}}, u, \Sigma = \{ \mathbf{add},
% \mathbf{mul} \}, \Sigma_{\mathbf{num}})$, where 
% $\mathbb{P}^+ = \{(r, r, 0) \ | \ \forall r \in \mathbb{R}^{+} \}$ 
% and 
% $d((r, a, b), (r', a', b')) = d_{\mathbb{R}}(r, r')$.
% Note that we do not modify our modular type inference algorithm and leave the
% instantiation the same.
% Let us write programs derivable in this type system using the
% $\vdash_{\mathbb{R}}$ judgement and $\vdash_{\mathbb{P}}$ for the
% paired representation instantiated previously. % todo: add backref
% We observe that programs step the same in both instantiations of the language
% and also that programs derivable in $\vdash_{\mathbb{R}}$ have the same type
% with $\vdash_{\mathbb{P}}$:
% \begin{lemma}[Derivablity]
% If $\Delta \ | \ \Gamma \vdash_{\mathbb{R}} e : \tau$,
% then
% $\Delta \ | \ \Gamma \vdash_{\mathbb{P}} e : \tau$ 
% \end{lemma}
% \begin{proof}
%   Proof by induction. $\vdash_{\mathbb{R}}$ has strictly less operations and the
%   associated rounding functions $\rho_{\mathbb{P}}$ and $u$ bounds are the same.
% \end{proof}
%
% We also observe that for a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, $q$ suffices to bound the
% maximum permitted round-off error.
%
% \begin{theorem}[Unpaired error soundness theorem]
% For a program $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we have that $ e \mapsto^{*} ((r, a,
% b), (r', a', b'))$ where $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Holds by applying our metric preservation theorem and unfolding our logical
%   relation and error metric.
% \end{proof}
%
% We are now ready to state our tightness theorem which guarantees that the paired
% representation produced error bounds no looser than the unpaired representation.
%
% \begin{lemma}[Tightness type inference lemma]\label{thm:tightness-helper}
%   If $b$ is always zero in our concrete domain and our program does not contain
%   subtraction, our type inference algorithm always infers that $b^{\uparrow} =
%   b^{\downarrow} = 0$.
% \end{lemma}
% \begin{proof}
%   We track all the intervals produced by the type inference algorithm. Intervals
%   are produced by $inj$ (base case) or by applying our lifted operations $op^{\#}$ (inductive case).
%   By induction, in both cases, our invariant $b^{\uparrow} = b^{\downarrow} =
%   0$ holds.
% \end{proof}
%
% \begin{theorem}[Tightness]
% For a $. \vdash_{\mathbb{R}} e :  M_q \mathbf{num}_i$, we know that $. \vdash e
% :  M_q \mathbf{num}_i$ and $e \mapsto^{*} ((r, a, b), (r', a', b'))$ where 
% $d_{\mathbb{R}}(r, r') \leq q$.
% \end{theorem}
% \begin{proof}
%   Unfold our logical relation and error metric. Note that our underlying carrier
%   set of $\mathbb{P}$ is zeroed out in the last component. By
%   Lemma~\ref{thm:tightness-helper}, we know that our type inference algorithm
%   will produce $b = b^{\uparrow} = b^{\downarrow} = 0$. 
%   By applying our a priori error theorem
%   (Theorem~\ref{thm:paired-a-priori-rel}), we have our terms neatly zero out and
%   simplify such that $d_{\mathbb{R}}(r, r') = ln(e^q) = q$.
% \end{proof}

% TODO: clarify how to start / use interval analysis, stitch together theorems
