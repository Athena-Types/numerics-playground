\section{Language} \label{sec:lang}
Our language is an extension of the Numerical Fuzz
\cite{numfuzz} language, a call-by-value affine lambda calculus.
Building off Numerical Fuzz \cite{numfuzz}, we are interested in developing a
modular family of languages for analyzing numerical round-off error. Modularity
enables differing floating-point bit precisions (e.g. 32-bit floats, 64-bit
floats) and floating-point operations to be soundly instantiated. In
Section~\ref{sec:encoding}, we will instantiate our family of languages with a
paired representation which will help provide both a priori and a posteriori
bounds.

In this section, we detail the construction of our modular family of languages.
We first describe the terms (Section~\ref{sec:terms}), types and static
semantics (Section~\ref{sec:types}), operational semantics
(Section~\ref{sec:dynamic-semantics}), and a modular interface for soundly
instantiating the language. Finally, we define a logical relation and prove
soundness.

% and logical relation for the family of
% languages (Section~\ref{sec:logical-relation}). Finally, using our logical relation
% to precisely specify the required invariants for instantiating our language, we
% define a modular interface for instantiating the language as well as prove
% soundness for any interface-conforming instantiation of the language
% (Section~\ref{sec:interface}). 
% We extend the Numerical Fuzz family of languages to support two key features:
% \begin{enumerate}
%   \item Error and sensitivity sharing between terms, through the addition of a
%   \textbf{factor} primitive (Section~\ref{sec:error-sharing}). This enables more
%   programs to be typed with tighter error bounds.
%   % todo: add section ref
%   \item Interval analysis, through the incorporation of \textit{bound
%   polymorphism} (Section~\ref{sec:bound-poly}). In
%   (Section~\ref{sec:tightness}), we will prove that this will result in error
%   bounds no looser than prior type-based approaches for forwards analysis.
% \end{enumerate}
% Finally, we
% provide a formal specification for soundly instantiating a particular
% language and prove soundness via a logical relations argument.
%
% \subsection{Sharing Error} \label{sec:error-sharing}
%
% \subsection{Type-based Interval Analysis and Bound Polymorphism} \label{sec:bound-poly}

\subsection{Terms} \label{sec:terms}
% \subsection{Syntax} \label{sec:syntax}
% We present the full syntax for types, terms, and evaluation contexts in
% Figure~\ref{fig:syntax}. 

Like many lambda calculi for linear type systems, our language supports
variables, function abstraction and application, $\pi_i$ for projection, $in_i$
for injection, and two different types of products.
Our term syntax has explicit terms to represent our effectful computation
(rounding to the nearest float: $\textbf{rnd}~e$) and coeffects (scaling
sensitivity: $[e]$). We have several terms for sequencing and structuring
computation. We have $\textbf{let-bind}$ for sequencing monadic computation,
$\textbf{let-cobind}$ for sequencing comonadic computation, $\textbf{let-pair}$
for unpacking tensors, and \textbf{case \ldots of \ldots} for unpacking sum
types, and \textbf{let} for sequencing variable assignment.
Note that our term language is more expressive than Numerical Fuzz as we do not
restrict the bound term in our let expressions to be values.

Our term language extends Numerical Fuzz's term language. We introduce a
language for intervals (shown in Figure~\ref{fig:syntax}) as well as explicit
terms to represent polymorphic abstraction $\bnd{(\Lambda \epsilon. e)}$ and
instantiation $\bnd{(e \{i\})}$. This is useful for incorporating an interval
analysis into the type inference algorithm, which we detail in
Section~\ref{sec:inference}.

\input{sections/01-syntax.tex}

\subsection{Types and static semantics}  \label{sec:static-semantics}
Following Numerical Fuzz, our type system has graded monad types $M_q \tau$ for
bounding the round-off error in $\tau$ by a real, non-negative grade $q$, scaled
metric types. We also have graded comonadic types $!_s \tau$ for bounding the
sensitivity of a type $\tau$ by a real, non-negative grade $s$.
Our language also supports linear function types $\tau_0 \multimap \tau$
corresponding to 1-sensitive functions.

Our typing judgements incorporate a graded effect and co-effect type system to
simulatenously track round-off error and function sensitivity. For example, the
following term with typing context and judgement indicates that the variable $x$
is $s$-sensitive in the expression $e$ and has worst-case round-off error
upper-bounded by $q$.
\begin{equation}
  x :_s \tau_0 \vdash e : M_q \tau_1
\end{equation}


Typing contexts have the following grammar: $\Gamma, \Delta ::= . | \Gamma, x :s
\tau$. Semantically, we can treat contexts $\Gamma$ as a partial map from
variables $x$ to pairs of sensitivities and types $(s, \tau)$. Similarly to
Numerical Fuzz, we can sum and scale typing contexts. We represent context
scaling as $\Gamma + \Delta$ and scaling by a real $s$ as $s \cdot \Gamma$. We
define pair context and scaling and then context summing and scaling below.

\begin{definition}[Pair summing]
  We can sum a pair of sensitivities and types $(s, \tau) + (s', \tau) = (s +
  s', \tau)$. Note that this is only well-defined if the types are syntacitcally
  equivalent.
\end{definition}

\begin{definition}[Context summing]
  A context $\Theta = \Gamma + \Gamma'$ if and only if $\forall x, \theta(x) =
  \Gamma(x) + \Gamma'(x)$ and is well defined.
\end{definition}

\begin{definition}[Pair scaling]
  We can scale a pair of sensitivities and types $s' \cdot (s, \tau) (s' \cdot s
  s', \tau)$. 
\end{definition}

\begin{definition}[Context scaling]
  A context $\Gamma' = s \cdot \Gamma$ if and only if $\forall x, \Gamma'(x) = s
  \cdot \Gamma'(x)$
\end{definition}

% describe rules, harp on linearity
The introduction and elimaination rules for $\otimes$, $\times$, and $\multimap$
mirror Numerical Fuzz and correspond to the standard introduction and
elimination rules in linear logic.
We are also able to scale typing contexts through the (! I) rule. This is useful
for instantiating functions with finitely scaled senstivity.
% todo: check that we can't be infinite and that this is up-to-date everywhere

The monadic grade upper-bounds the maximum possible round-off error possible.
Most of the rules for controlling the grade, (Ret), (Rnd), ($M_u$ E),
(Subsumption) are taken from Numerical Fuzz and are our core reasoning
principles for reasoning about round-off error. Intuitively, (Ret) introduces no
round-off error and (Rnd) introduces round-off error $u$ corresponding to the
unit round-off constant. Note that $M_u E$ is the characteristic rule for
\textbf{let-cobind} that incorporates senstivity and round-off information.
Our language also introduces a new (Factor) rule for reasoning about monadic
computations with round-off error, which allows for tighter error analyses. We
detail the (Factor) rule and walk through an example in
Section~\ref{sec:structure}.

In this paper, we use the color $\bnd{\textit{blue}}$ to denote bound
polymorphism. 
In the (\bnd{Widen}), (\bnd{Bvar}), (\bnd{Bop}), ($\forall-I$), and
($\forall-E$) rules, we further extend Numerical Fuzz with an interval-style
analysis by annotating $\textbf{num}_{\bnd{i}}$ types with a subscript bound
with the grammar $\bnd{i}$ shown in Figure~\ref{fig:syntax}. 
We also extend Numerical Fuzz by adding expressions in more places
(e.g. the application rule) and a $\textbf{factor}$ primitive to enable tighter
error bounds. To support operations that have polymorphic bounds, we
additionally modify our (Op) typing rule from Numerical Fuzz.
% For presentational purposes, we present a restricted form of the
% typing rule to make the modular interface easier to follow.

\begin{figure}
%% ROW1
\begin{center}
%% unit
\AXC{}
\RightLabel{(Unit)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \langle \rangle : \mathbf{unit}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% var
\AXC{$s \ge 1$}
\RightLabel{(Var)}
  \UIC{$\bnd{\Delta \ |} \ \Gamma, x:_s \tau, \Theta \vdash x : \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% fun
\AXC{$\bnd{\Delta \ |} \ \Gamma, x:_1 \tau_0 \vdash e : \tau$}
\RightLabel{($\multimap$ I)}
\UnaryInfC{$\bnd{\Delta \ |} \ \Gamma \vdash \lambda x. e : \tau_0 \multimap \tau $}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% app
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0 \multimap \tau$}
\AXC{$\bnd{\Delta \ |} \ \Theta \vdash f : \tau_0 $}
\RightLabel{($\multimap$ E)}
\BinaryInfC{$\bnd{\Delta \ |} \ \Gamma + \Theta \vdash ef : \tau $}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% dep prod intro
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0$}
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash f : \tau_1$}
\RightLabel{($\times$ I)}
\BinaryInfC{$\bnd{\Delta \ |} \ \Gamma \vdash \langle e, f \rangle: \tau_0 \times \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%%


%% ROW2
%% dep prod elim
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_1 \times \tau_2$}
\RightLabel{($\times$ E)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash {\pi}_i \ e : \tau_i$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% ind prod intro
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0 $}
\AXC{$\bnd{\Delta \ |} \ \Theta \vdash f : \tau_1$}
\RightLabel{($\tensor$ I)}
\BIC{$\bnd{\Delta \ |} \ \Gamma + \Theta \vdash (e, f) : \tau_0 \tensor \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% ind prod elim
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0 \tensor \tau_1$ }
\AXC{$\bnd{\Delta \ |} \ \Theta,x:_s \tau_0,y:_s\tau_1 \vdash f: \tau $}
\RightLabel{($\tensor$ E)}
\BIC{$\bnd{\Delta \ |} \ s * \Gamma + \Theta \vdash \letpair (x,y) \ = \ e \ \tin \ f : \tau $}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% ind sum intro
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0$ }
\RightLabel{($+$ $\text{I}_i$)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \mathbf{in}_i \ e : \tau_0 + \tau_1$}
\bottomAlignProof
\DisplayProof
\vskip 1em

% sum elim
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau_0+\tau_1$}
\AXC{$\bnd{\Delta \ |} \ \Theta, x:_s \tau_0 \vdash f_1 : \tau$ \qquad
$\Delta \ | \ \Theta, x:_s \tau_1 \vdash f_2: \tau$}
\RightLabel{($+$ E)}
\AXC{$s > 0$}
\TIC{$\bnd{\Delta \ |} \ s * \Gamma + \Theta \vdash \mathbf{case} \ e \ \mathbf{of} \ (\mathbf{in}_1 x.f_1 \ | \ \mathbf{in}_2 x.f_2) : \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

% box elim
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : {!_s \tau_0}$}
\AXC{$\bnd{\Delta \ |} \ \Theta, x:_{t*s} \tau_0 \vdash f : \tau$}
\RightLabel{($!$ E)}
\BIC{$\bnd{\Delta \ |} \ t * \Gamma + \Theta \vdash \letcobind x = e \ \tin \ f : \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% ops
\AXC{$\{ \mathbf{op} : \bnd{\forall \epsilon_0, \epsilon_1,} \tau_0 \multimap \tau_1 \} \in \Sigma$}
\RightLabel{(Op)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \mathbf{op} : \bnd{\forall \epsilon_0, \epsilon_1,} \tau_0 \multimap \tau_1 $}
\bottomAlignProof
\DisplayProof
\vskip 1em
%%


%% ROW 5

%%% ROW 6

% let 
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e :  \tau_0$}
\AXC{$\bnd{\Delta \ |} \ \Theta, x:_{s} \tau \vdash f : \tau$}
\RightLabel{(Let)}
\BIC{$\bnd{\Delta \ |} \ s * \Gamma + \Theta \vdash \letassign x = e \ \tin \ f : \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% const
% TODO: need to describe inj function to some degree here, I suppose
\AXC{$k \in \textit{num}$}
\RightLabel{(Const)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash k : \num_{\bnd{inj(k)}}$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%% widen
\AXC{$(k_0, k_1) \sqsubseteq (k'_0, k'_1)$}
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \num_{\bnd{(k_0, k_1)}}$}
\RightLabel{(\bnd{Widen})}
\BIC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \num_{\bnd{(k'_0, k'_1)}}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% box intro
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau$ }
\RightLabel{($!$ I)}
\UIC{$\bnd{\Delta \ |} \ s * \Gamma \vdash [e] : {!_s \tau}$}
\bottomAlignProof
\DisplayProof
\vskip 1em

%%% ROW 7

%% subsumption
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e :  M_q \tau$}
\AXC{$r \ge q$}
\RightLabel{(Subsumption)}
\BIC{$\bnd{\Delta \ |} \ \Gamma \vdash e :  M_{r} \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
% factor
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : (M_q \tau_0) \times (M_r \tau_1)$}
\RightLabel{(Factor)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \factor \ e : M_{max(q,r)} (\tau_0 \times \tau_1)$}
\bottomAlignProof
\DisplayProof
\vskip 1em
%% return
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \tau$}
\RightLabel{(Ret)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \ret e : M_0 \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
%% RND
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : \num_{\bnd{i}}$}
\RightLabel{(Rnd)}
\UIC{$\bnd{\Delta \ |} \ \Gamma \vdash \rnd \ e : M_u \ \num_{\bnd{i}}$}
\bottomAlignProof
\DisplayProof
\vskip 1em


%%% ROW 8


% let-bind
\AXC{$\bnd{\Delta \ |} \ \Gamma \vdash e : M_r \tau_0$}
\AXC{$\bnd{\Delta \ |} \ \Theta, x:_{s} \tau_0 \vdash f : M_{q} \tau$}
\RightLabel{($M_u$ E)}
\BIC{$\bnd{\Delta \ |} \ s * \Gamma + \Theta \vdash \letbind x = e \ \tin \ f : M_{s*r+q} \tau$}
\bottomAlignProof
\DisplayProof
\vskip 1em

% bvar
\AXC{}
\RightLabel{($\bnd{\text{Bvar}}$)}
\UIC{$\Delta, \epsilon : \textbf{bnd} \vdash \epsilon : \textbf{bnd}$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$\Delta \vdash b_0 : \textbf{bnd}$}
\AXC{$\ldots$}
\AXC{$\Delta \vdash b_c : \textbf{bnd}$}
\AXC{$\textbf{iop}_c \in \Sigma_{\textbf{bnd}}$}
\RightLabel{(\bnd{\text{Bop}})}
\QIC{$\Delta \vdash \textbf{iop}_c(i_0, \ldots, i_c) : \textbf{bnd}$}
\bottomAlignProof
\DisplayProof
\vskip 1em

\AXC{$\Delta, \epsilon : \textbf{bnd} \ | \ \Gamma \vdash e : \tau$}
\AXC{$\epsilon \not\in FTV(\Gamma)$}
\RightLabel{(\bnd{$\forall$-I})}
\BIC{$\Delta \ | \ \Gamma \vdash \Lambda \epsilon . e : \forall \epsilon . \tau$}
\bottomAlignProof
\DisplayProof
\hskip 0.5em
\AXC{$\Delta \ | \ \Gamma \vdash e : \forall \epsilon . \tau$}
\AXC{$\Delta \vdash i : \textbf{bnd}$}
\RightLabel{(\bnd{$\forall$-E})}
\BIC{$\Delta \ | \ \Gamma \vdash e~\{i\} : \tau[i/\epsilon]$}
\bottomAlignProof
\DisplayProof

\vskip 3em

\end{center}
    \caption{Typing rules for \Lang, with $s,t,q,r,u \in \NNR \cup \{\infty\}$
      and for $i \in \{ 1, 2 \}$ where $u$ is a fixed constant parameter (see
      Definition~\ref{def:numfuzz-interface} for details on picking an adequate
      constant). $FTV(\Gamma)$ refers to all the free type variables (e.g.
    $\epsilon_0, \epsilon_1$) in $\Gamma$.}
    \label{fig:typing_rules}
\end{figure}

\subsection{Operational Semantics} \label{sec:dynamic-semantics}
In Figure~\ref{fig:sub_eval_rules}, we define the operational semantics rewrite
relation $\mapsto$ to map from closed terms in \Lang to closed terms in \Lang.
Note that we only define our language over closed terms. 
Rather than stapling together and reasoning about two separate semantics, an
ideal and approximate semantics, we combine our reasoning under one rewrite
relation. This setup simplifies the structure of our logical relation and main
soundness theorem easier to follow.

Accordingly, the interesting stepping rules that differ from Numerical Fuzz are
the $\textbf{rnd}$ rule, which steps a value to an ideal and rounded value, the
$\textbf{ret}$ rule, which steps a value to the diagonal map, and the
$\textbf{let-bind}$ stepping rule, which composes rounded computation. 
For our new \textbf{factor} primitive, we can its operational semantics as a
reassociating of the underlying ideal and approximate terms.

We also extend the Numerical Fuzz language to allow expressions in more places.
We define evaluation contexts to separate the structural plumbing of the
operational semantics from the more interesting portions of the operational
semantics.
Evaluation contexts and the characteristic \textit{context rule} allow us to
simplify reasoning about the rewrite relation, which we factor out into a
separate lemma in our soundness proof. 
Our rewrite relation has a restricted ability to step interval bounds and
eliminate polymorphic variables. For example, the bound $(0, 1) + (2,3) \mapsto
(2, 4)$.

\begin{figure}
\begin{center}
\begin{equation*}
\begin{aligned}[c]
  \mathbf{op} \ \bnd{\{i_0\}} \ \bnd{\{i_1\}} \ v &\mapsto op \ \bnd{\{i_0\}} \
    \bnd{\{i_1\}} \ v \\
	\pi_i\langle v_1,v_2 \rangle &\mapsto v_i \\
	(\lambda x.e) \ v &\mapsto e[v/x] \\
  \rnd k &\mapsto (k, \rho(k))
\end{aligned}
\quad
\begin{aligned}[c]
	\letassign x = v \ \tin \ e &\mapsto e[v/x] \\
  \letpair (x, y) = (v, w) \ \tin \ e &\mapsto e[v/x][w/y] \\
  \letcobind x = [v] \ \tin \ e &\mapsto e[v/x] \\
  \ret v &\mapsto (v, v)
\end{aligned}
\end{equation*}
\vskip -1em
\begin{align*}
	\mathbf{case} \ (\mathbf{in}_i \ v) \ \mathbf{of} \ (\mathbf{in}_1 \ x.e_1 \ | \ \mathbf{in}_2 \ x.e_2 )  &\mapsto e_i[v/x]
   \\
  \factor ((v_1, v_2), (v_3, v_4)) &\mapsto ((v_1, v_3), (v_2, v_4)) \\
  \textbf{iop}_c((k_0, k_1), \ldots) &\mapsto \textit{iop}_c((k_0, k_1) \ldots)
  \\
  \Lambda \epsilon . e~{(k_0, k_1)} &\mapsto e[(k_0, k_1)/\epsilon] \\
\end{align*}
  \vskip -0.25em
  \RightLabel{(Context Rule)}
  \AXC{$e \mapsto e'$}
  \UIC{$C[e] \mapsto C[e']$}
	\DisplayProof
	
  \vskip 0.4em
  \AXC{$f[v_1/x] \mapsto^* (v_3, v_4)$}
  \AXC{$f[v_2/x] \mapsto^* (v_5, v_6)$}
  \BIC{$\letbind x = (v_1, v_2) \ \tin \ f \mapsto (v_3, v_6)$}
  \DisplayProof
\end{center}
    \caption{Substitution-style evaluation rules for \Lang. Parameterized for $i
    \in \{1, 2 \}$. $op$ is a higher-order metavar. When bolded $\mathbf{op}$
    refers to the syntax and when italicized $op$ refers to the corresponding
    function on syntactic values (it may be a constant function).}
    \label{fig:sub_eval_rules}
\end{figure}

\subsection{Modular Interface} \label{sec:interface}
To define the modular interface that enables sound instantiation of the
Numerical Fuzz family of programming languages, we first define distances
between intervals, expressions, vectors of expressions, and substitutions. This
notation will be useful later for stating and proving type soundness. 

Our syntactic definition for distance, $d_\tau$ and the distance between
syntactic values $\mathcal{SD}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance) and $\mathcal{SDV}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance for $\mathcal{V}$alues) are closely related. Some care is
needed to ensure that the relation is well-founded. We define our distance over
syntactic values as follows:

\begin{definition}[Distance between closed syntactic terms]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \mathcal{SDV}_{\tau}(v_0, v_1)
    &\text{ if } e_0 \mapsto^{*} v_0 \text{ and } e_1 \mapsto^{*} v_1 \\
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \infty &\text{ otherwise } \\
    \mathcal{SDV_{\mathbf{unit}}}(v, w) &\triangleq 0 &\text{ for } v, w =
      \langle \rangle \\
    \mathcal{SDV}_{\mathbf{num_{b}}}(k_0, k_1) &\triangleq 
      d_\mathbf{num} &\text{ for } k_0, k_1 \in \mathbb{R} \\
    \mathcal{SDV}_{\tau_0 \times \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq max(\mathcal{SDV}_{\tau_0}(v_0, w_0),~\mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 \otimes \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau_0}(v_0, w_0) + \mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 + \tau_1}(\tin_i~v, \tin_i~w) 
      &\triangleq \mathcal{SDV}_{\tau_i}(v, w)
    \\
    \mathcal{SDV}_{\tau_0 \multimap \tau_1}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\tau_0}} \mathcal{SD}_{\tau_1}(v_0~w,~v_1~w)
    \\
    % max: double check
    \mathcal{SDV}_{!_s \tau}([v], [w]) 
      &\triangleq s \cdot \mathcal{SDV}_{\tau}(v, w)
    \\
    \mathcal{SDV}_{M_q~\tau}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau}(v_0, w_0)
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k_0, k_1)) 
      &\triangleq 0 
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k'_0, k'_1)) 
      &\triangleq \infty &\text{ otherwise }
    \\
    \mathcal{SDV}_{\forall \epsilon . \tau}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\textbf{bnd}}} 
      \mathcal{SD}_{\tau_1}(v_0~\{w\},~v_1~\{w\})
    \\
    \mathcal{SDV_{\tau}}(v, w) &\triangleq \infty &\text{ otherwise } \\
  \end{aligned}
  \end{equation}
\end{definition}

We incrementally build up to the definition of distance between substitutions
below.

\begin{definition}[Distance between expressions.]
For any two closed expressions $e_0, e_1$ falling in same type relation $e_0,
e_1 \in R_\tau$ (where $\tau$ is a closed type), we can write $e_0 \sim_r e_1 :
\tau$ where $\mathcal{SD}_{\tau}(e_0, e_1) \leq r$. 
\end{definition}

\begin{definition}[Distance between expression vectors.]
    We write write vectors of expressions (e.g. for substitutions) 
    % $\sigma =
    % \sigma_{\Delta} \ | \ \sigma_{\Gamma}, \sigma' = \sigma'_{\Delta} \ | \
    % \sigma'_{\Gamma}$
    for a given typing context $\Delta \ | \ \Gamma$ that: $\sigma \sim_{\gamma} \sigma' : \Delta \ | \ \Gamma$ for a \textit{distance vector}
    if and only if
    $\gamma = r_0, r_1, \ldots$
    where
    $\sigma = \sigma_{\Delta}, e_0,~\ldots,~e_n$ 
    and 
    $\sigma' = \sigma_{\Delta}, e'_0,~\ldots,~e'_n$ 
    such that:
    $$
    e_0 \sim_{r_0} e'_0 : \tau_0~[\sigma_{\Delta}],
    ~\ldots,
    ~e_n \sim_{r_n} e'_n : \tau_n~[\sigma_{\Delta}]
    $$
    where $\sigma_{\Delta}$ is a interval vector with no free varaibles.
    Note that the distance between expression vectors are undefined when the
    interval vector $\sigma_{\Delta}$ differs between substitutions.
\end{definition}

\begin{definition}[Enviroment compatibility.]
We also say that a substitution vector 
$$\sigma_{\Delta}, [e_0/x_0, \ldots, e_n/x_n]$$
is \textit{compatible} with a typing context 
$x_0 : \tau_0, \ldots, x_n : \tau_n$
if each term 
$e_0 \in \mathcal{R}_{\tau_0~[\sigma_{\Delta}]}, 
\ldots,
e_n \in \mathcal{R}_{\tau_n~[\sigma_{\Delta}]}$ where all types are closed by the interval vector $\sigma_{\Delta}$.
\end{definition}

\begin{definition}[Dot product of distance vectors.]
Our definition for the dot product of a distance vector $\gamma = r_0, \ldots,
r_n$ with respect to a context $\Gamma$ with sensitivities $s_0, \ldots, s_n$ is
the same as Fuzz \cite{Fuzz}: $\gamma \cdot \Gamma = \Sigma_{i = 1}^n r_i s_i$.
\end{definition}

In the remainder of the paper, we'll treat and represent our distance vector
$\gamma$ as a lookup function and assume that there is an implicit fixed
ordering on the variables.
\begin{definition}[Distance vector lookup.]
  We write, for a distance vector $\gamma$ and variable $x$, $\gamma(x)$ for the
  lookup of the distance of variable $x$ in $\gamma$. If the variable $x$ is not
  in the domain, $\gamma(x) = 0$ by default. 
\end{definition}

We are now ready to state the interface for soundly instantiating Numerical
Fuzz. Numerical Fuzz is a modular family of programming langauges paramterized
by the appropriate $\rho$, constant parameter $u$, and the appropriate set of
numeric computations $\Sigma$.  
% We can now state a few assumptions about how the operational and static
% semantics of $\mathbf{rnd}$ and $\Sigma$ (for $\mathbf{op}$) relate.
It is the proof obligation for any language designer instantiating the language
to demonstrate that these properties hold in order for our paramterized
soundness theorems to follow.
\begin{definition}[Interface for instantiating Numerical Fuzz.]
  \label{def:numfuzz-interface}
  The interface for Numerical Fuzz consists of  $\textit{num}$,
  $d_\textbf{num}$, $\rho$, $u$, $\Sigma$, and $\Sigma_{\mathbf{bnd}}$ such that
  the following properties hold: 
\begin{description}
  \item[a) The set \textit{num} and distance function $d_\textbf{num}$ form a
  metric space.]
  \item[b) Property of $\rho$ and constant parameter $u$.] We assume that the
    $\forall k \in \textit{num}, d_{\mathbf{num}}(\rho(k), k)
    \leq u$ where $u$ is the grade in the $\mathbf{rnd}$ typing rule.
  \item[c) Property of $\mathbf{iop}$: closure over intervals ($\textit{num}^2$).] We further need to
    assume that for every operation $\mathbf{iop}_c : \Sigma_\textbf{num}$, we
    have that for any sequence of bounds $b_0, b_1, \ldots : \textbf{bnd}$ the
    corresponding metalevel function will actually map concrete bounds to concrete bounds
    where 
    $\textit{iop}_c((k'_0, k'_1), \ldots, (k'_n, k'_n)) = (k_0, k_1) : \textbf{bnd}$
    holds.
  \item[d) Property of $\mathbf{op}$: metric preservation.] 
    \footnote{Note that we could make this portion of the interface more general
    by definining it in terms of the logical relation in
    Section~\ref{sec:logical-relation}. We have opted to
  keep the interface minimal for presentational purposes.}
    We can view $\textit{op}$ as a (possibly constant) metalevel function.
    We also assume that for every operation has the following two shapes
    $\mathbf{op} : \forall \epsilon_0, \epsilon_1 . (\textbf{num}_{\epsilon_0}
    \times \textbf{num}_{\epsilon_1}) \multimap \textbf{num}_i \in \ \Sigma$ 
    and
    $\mathbf{op} : \forall \epsilon_0, \epsilon_1 . (\textbf{num}_{\epsilon_0}
    \otimes \textbf{num}_{\epsilon_1}) \multimap \textbf{num}_i \in \ \Sigma$ 
    where for the corresponding $\textit{op} \ \bnd{\{i_0\}} \ \bnd{\{i_1\}} \
    v$ for all $\bnd{i_0}, \bnd{i_1} \in \mathbb{P}^2$ 
    and for all v mapping bounds and syntactic values in
    $(\textbf{num}_{\epsilon_0} \otimes \textbf{num}_{\epsilon_1})$
    and
    $(\textbf{num}_{\epsilon_0} \times \textbf{num}_{\epsilon_1})$
    to $\textbf{num}_i$ is 1-sensitive as measured by $\mathcal{SD}$.

    % $\mathcal{VR}_{\tau}$ where 
    % metric preservation holds: For all $\sigma
    % \sim_{\gamma} \sigma' : \Gamma$, $\textit{op}~\sigma \sim_{\gamma \cdot
    % \Gamma} \textit{op} : \tau$.
    % Or, expanded:
    % \begin{description}
    %   \item[\underline{1) Type denotation.}] $\mathit{op} \in
    %     \mathcal{R}_{\tau}$. The metalevel operation will step to something in the
    %     value relation.
    %   \item[\underline{2) Context sensitivity.}]
    %     This property states that for every $\textbf{op}$, the
    %     corresponding $\textit{op}$ preserves the metric. For any two
    %     substitutions $\sigma, \sigma'$ such that:
    %     $\sigma \sim_{\gamma} \sigma' : \Gamma$
    %     we have that
    %     $\mathcal{SD}_{\tau}(\textit{op}~\sigma, \textit{op}~\sigma') \leq \gamma \cdot \Gamma$.
    % \end{description} 
  % \item[c) Property of $\mathbf{op}$: metric preservation.] 
  %   We can view $\textit{op}$ as a (possibly constant) metalevel function.
  %   We also assume that for every operation
  %   $\mathbf{op} : \tau \in \ \Sigma$ we have a
  %   corresponding function $op$ mapping syntactic values in
  %   $\mathcal{VR}_{\tau}$ where metric preservation holds: For all $\sigma
  %   \sim_{\gamma} \sigma' : \Gamma$, $\textit{op}~\sigma \sim_{\gamma \cdot
  %   \Gamma} \textit{op} : \tau$.
  %   Or, expanded:
  %   \begin{description}
  %     \item[\underline{1) Type denotation.}] $\mathit{op} \in
  %       \mathcal{R}_{\tau}$. The metalevel operation will step to something in the
  %       value relation.
  %     \item[\underline{2) Context sensitivity.}]
  %       This property states that for every $\textbf{op}$, the
  %       corresponding $\textit{op}$ preserves the metric. For any two
  %       substitutions $\sigma, \sigma'$ such that:
  %       $\sigma \sim_{\gamma} \sigma' : \Gamma$
  %       we have that
  %       $\mathcal{SD}_{\tau}(\textit{op}~\sigma, \textit{op}~\sigma') \leq \gamma \cdot \Gamma$.
  %   \end{description} 
  %   \item[d) Property of $\mathbf{iop}$: closure over intervals ($\textit{num}^2$).] We further need to
  %     assume that for every operation $\mathbf{iop}_c : \Sigma_\textbf{num}$, we
  %     have that for any sequence of bounds $b_0, b_1, \ldots : \textbf{bnd}$ the
  %     corresponding metalevel function will actually map concrete bounds to concrete bounds
  %     where 
  %     $\textit{iop}_c((k'_0, k'_1), \ldots, (k'_n, k'_n)) = (k_0, k_1) : \textbf{bnd}$
  %     holds.
\end{description}
\end{definition}

\subsection{Logical Relation} \label{sec:logical-relation}
In our language, we only reason about closed types and terms. Let $CV(\tau)$ be
the closed values of type $\tau$ and $CE(\tau)$ be the closed expressions of
type $\tau$. Then we can define a unary logical relation over types which
capture the core information needed to prove our error soundness theorem.

\begin{definition}[Logical relation]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{R_{\tau}} &\triangleq 
      \{ e \ | \ e \in CE(\tau) \text{ and } \exists v
        \in CV(\tau) \text{ s.t. } e \mapsto^{*} v \text{ and } v \in \mathcal{VR_{\tau}} 
      \} \\
    \mathcal{VR_{\mathbf{unit}}} &\triangleq \{ \langle \rangle \} \\
    \mathcal{VR}_{\mathbf{num}_{b}} &\triangleq 
      \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} 
      \hspace{22em} \text{if } b \mapsto^* (k_0, k_1) \\
    \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} &\triangleq 
      \{ r \ | \ r \in \mathit{num} \text{ and } k_0 \leq r \leq k_1 \} \\
    \mathcal{VR_{\mathbf{\tau_0 \times \tau_1}}} &\triangleq 
      \{ \langle v, w \rangle \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 \otimes \tau_1}}} &\triangleq 
      \{ ( v, w ) \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 + \tau_1}}} &\triangleq 
      \{ \mathbf{inl}~v \ | \ v \in \mathcal{R}_{\tau_0} \} 
      \cup
      \{ \mathbf{inr}~v \ | \ v \in \mathcal{R}_{\tau_1} \} \\
    \mathcal{VR_{\mathbf{\tau_0 \multimap \tau_1}}} &\triangleq 
      \{ \lambda x . e \ | \ \forall w_0, w_1 \in \mathcal{VR}_{\tau_0}, \\ & \quad \quad \ (\lambda x.e)~w_0, (\lambda x . e)~w_1 \in
      \mathcal{R}_{\tau_1} \text{ and } \mathcal{SD}_{\tau_1}((\lambda x . e)~w_0, (\lambda x . e)~w_1) \leq
      \mathcal{SD}_{\tau_0}(w_0, w_1) \} \\
    \mathcal{VR_{\mathbf{!_s \tau}}} &\triangleq 
      \{ [~v~] \ | \ v \in \mathcal{R}_{\tau} \} \\
    % spicy hot new stuff
    \mathcal{VR_{\mathbf{M_q \tau}}} &\triangleq 
      \{ (v, w) \ | \ v, w \in \mathcal{R}_{\tau} \text{ and } \mathcal{SDV}_{\tau}(v, w)
      \leq q \} \\
    \mathcal{VR}_{\textbf{bnd}} &\triangleq \{ (k_0, k_1) \ | \ k_0 \leq k_1 \ \forall k_0, k_1 \in
    \textit{ num } \} \\
    \mathcal{VR_{\forall \epsilon. \tau}} &\triangleq 
      \{ ((k_0, k_1), v) \ | \ \forall (k_0, k_1) \in
      \mathcal{VR}_{\textbf{bnd}} \text{ s.t. } v ~ \{(k_0, k_1)\} \in
      \mathcal{R}_{\tau[(k_0, k_1) / \epsilon]}\} \\
  \end{aligned}
  \end{equation}
\end{definition}

\subsection{Soundness} \label{sec:soundness}
\begin{lemma}[$\mathcal{SD}$ is a metric]
  $\mathcal{SD}$ forms a metric over our syntactic terms; in particular it
  satisfies:
  \begin{enumerate}
    \item Distance from any point to itself is zero: $\forall x,~\mathcal{SD}(x,
      x) = 0$.
    \item Positivity: $\forall x, y,~\mathcal{SD}(x, y) \geq 0$.
    \item Symmetry: $\forall x, y,~\mathcal{SD}(x, y) = \mathcal{SD}(y, x)$.
    \item Triangle inequality: $\forall x, y, z,~\mathcal{SD}(x, z) \leq
      \mathcal{SD}(x, y) + \mathcal{SD}(y, z)$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  The properties holds for the base cases of $\mathcal{SDV}$ and follow for the
  remaining cases by our inductive hypothesis. Since our operational semntics is
  deterministic, the properties follow for $\mathcal{SD}$.
\end{proof}

\begin{lemma}[$\mathcal{SD}$ is preserved under stepping]
  If $e_0 \mapsto e'_0$, then for any $e_1$, $\mathcal{SD}(e_0, e_1) =
  \mathcal{SD}(e'_0, e_1)$.
\end{lemma}
\begin{proof}
  Holds by inspection of the definition of $\mathcal{SD}$.
\end{proof}
Note that by metric symmetry, $\mathcal{SD}$ is preserved under stepping on both
sides.

\input{sections/05-type-error-soundness.tex}
