\section{Language} \label{sec:lang}
Our language is an extension of the Numerical Fuzz
\cite{NumFuzz} language, a call-by-value affine lambda calculus.
Building off Numerical Fuzz \cite{NumFuzz}, we are interested in developing a
modular family of languages for analyzing numerical round-off error. Modularity
enables differing floating-point bit precisions (e.g. 32-bit floats, 64-bit
floats) and floating-point operations to be soundly instantiated. In
Section\ref{sec:encoding}, we will instantiate our family of languages with a
paired representation which will help provide both a priori and a posteriori
bounds.

In this section, we detail the construction of our modular family of languages.
We first describe the terms (Section~\ref{sec:terms}), types and static
semantics (Section~\ref{sec:types}), operational semantics
(Section~\ref{sec:dynamic-semantics}), and a modular interface for soundly
instantiating the language. Finally, we define a logical relation and prove
soundness.

% and logical relation for the family of
% languages (Section~\ref{sec:logical-relation}). Finally, using our logical relation
% to precisely specify the required invariants for instantiating our language, we
% define a modular interface for instantiating the language as well as prove
% soundness for any interface-conforming instantiation of the language
% (Section~\ref{sec:interface}). 
% We extend the Numerical Fuzz family of languages to support two key features:
% \begin{enumerate}
%   \item Error and sensitivity sharing between terms, through the addition of a
%   \textbf{factor} primitive (Section~\ref{sec:error-sharing}). This enables more
%   programs to be typed with tighter error bounds.
%   % todo: add section ref
%   \item Interval analysis, through the incorporation of \textit{bound
%   polymorphism} (Section~\ref{sec:bound-poly}). In
%   (Section~\ref{sec:tightness}), we will prove that this will result in error
%   bounds no looser than prior type-based approaches for forwards analysis.
% \end{enumerate}
% Finally, we
% provide a formal specification for soundly instantiating a particular
% language and prove soundness via a logical relations argument.
%
% \subsection{Sharing Error} \label{sec:error-sharing}
%
% \subsection{Type-based Interval Analysis and Bound Polymorphism} \label{sec:bound-poly}

\subsection{Terms} \label{sec:terms}
% \subsection{Syntax} \label{sec:syntax}
% We present the full syntax for types, terms, and evaluation contexts in
% Figure~\ref{fig:syntax}. 

Building off the term language for \cite{NumFuzz}, our term syntax has explicit
terms to represent scaling ($[e]$), rounding ($\textbf{rnd}~e$). For sequencing
and combining computation, we have $\textbf{let}$, $\textbf{let-pair}$,
$\textbf{let-bind}$, and $\textbf{let-cobind}$ for sequencing assignment, tuple
unpacking, monadic, and comonadic computations respectively. Most exotically, we
have a language for intervals (shown in Figure~\ref{fig:syntax}) as well as
explicit terms to represent polymorphic abstraction $\bnd{(\Lambda \epsilon.
e)}$ and instantiation $\bnd{(e \{i\})}$. This is useful for incorporating a
interval analysis into the type system, which we detail in the following
section.

\input{sections/01-syntax.tex}

\subsection{Types and static semantics}  \label{sec:static-semantics}
Following Numerical Fuzz, our type system has monad types $M_u \tau$ for
tracking the round-off error in $\tau$ and bounding it by a real, non-negative
grade $u$, scaled metric types $!_s \tau$, and linear function types $\tau_0
\multimap \tau$ for 1-sensitive functions.

We extend Numerical Fuzz with an interval-style analysis by annotating
$\textbf{num}_{\bnd{i}}$ types with a subscript bound with the grammar $\bnd{i}$
shown in Figure~\ref{fig:syntax}. For the remainder of this paper we use the
color $\bnd{\textit{blue}}$ to denote bound polymorphism.
We also extend Numerical Fuzz by adding expressions in more places (e.g. the
application rule) and a $\textbf{factor}$ primitive to enable tighter error
bounds. 

\input{sections/02-static-semantics.tex}

\subsection{Operational Semantics} \label{sec:dynamic-semantics}
We extend the Numerical Fuzz language to allow expressions in more places. To
separate the structural plumbing of the operational semantics from the more
interesting portions of the operational semantics, we define evaluation
contexts.
We use evaluation contexts and the characteristic \textit{context rule} to
simplify reasoning about the rewrite relation. Our rewrite relation has a
restricted ability to step interval bounds and eliminate polymorphic variables.
For example, the bound $(0, 1) + (2,3) \mapsto (2, 4)$.

In Figure~\ref{fig:sub_eval_rules}, we define the operational semantics rewrite
relation $\mapsto$ to map from closed terms in \Lang to closed terms in \Lang.
Note that we only define our language over closed terms. 

\input{sections/03-dynamic-semantics.tex}

\subsection{Modular Interface} \label{sec:interface}
To define the modular interface that enables sound instantiation of the
Numerical Fuzz family of programming languages, we first define distances
between intervals, expressions, vectors of expressions, and substitutions. This
notation will be useful later for stating and proving type soundness. 

Our syntactic definition for distance, $d_\tau$ and the distance between
syntactic values $\mathcal{SD}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance) and $\mathcal{SDV}_\tau$ (for $\mathcal{S}$yntactic
$\mathcal{D}$istance for $\mathcal{V}$alues) are closely related. Some care is
needed to ensure that the relation is well-founded. We define our distance over
syntactic values as follows:

\begin{definition}[Distance between closed syntactic terms]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \mathcal{SDV}_{\tau}(v_0, v_1)
    &\text{ if } e_0 \mapsto^{*} v_0 \text{ and } e_1 \mapsto^{*} v_1 \\
    \mathcal{SD_{\tau}}(e_0, e_1) &\triangleq \infty &\text{ otherwise } \\
    \mathcal{SDV_{\mathbf{unit}}}(v, w) &\triangleq 0 &\text{ for } v, w =
      \langle \rangle \\
    \mathcal{SDV}_{\mathbf{num_{b}}}(k_0, k_1) &\triangleq 
      d_\mathbf{num} &\text{ for } k_0, k_1 \in \mathbb{R} \\
    \mathcal{SDV}_{\tau_0 \times \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq max(\mathcal{SDV}_{\tau_0}(v_0, w_0),~\mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 \otimes \tau_1}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau_0}(v_0, w_0) + \mathcal{SDV}_{\tau_0}(v_1, w_1))
    \\
    \mathcal{SDV}_{\tau_0 + \tau_1}(\tin_i~v, \tin_i~w) 
      &\triangleq \mathcal{SDV}_{\tau_i}(v, w)
    \\
    \mathcal{SDV}_{\tau_0 \multimap \tau_1}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\tau_0}} \mathcal{SD}_{\tau_1}(v_0~w,~v_1~w)
    \\
    % max: double check
    \mathcal{SDV}_{!_s \tau}([v], [w]) 
      &\triangleq s \cdot \mathcal{SDV}_{\tau}(v, w)
    \\
    \mathcal{SDV}_{M_q~\tau}((v_0, v_1), (w_0, w_1)) 
      &\triangleq \mathcal{SDV}_{\tau}(v_0, w_0)
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k_0, k_1)) 
      &\triangleq 0 
    \\
    \mathcal{SDV}_{\textbf{bnd}}((k_0, k_1), (k'_0, k'_1)) 
      &\triangleq \infty &\text{ otherwise }
    \\
    \mathcal{SDV}_{\forall \epsilon . \tau}(v_0, v_1) 
      &\triangleq \text{sup}_{w \in \mathcal{VR}_{\textbf{bnd}}} 
      \mathcal{SD}_{\tau_1}(v_0~\{w\},~v_1~\{w\})
    \\
    \mathcal{SDV_{\tau}}(v, w) &\triangleq \infty &\text{ otherwise } \\
  \end{aligned}
  \end{equation}
\end{definition}

\begin{definition}[Distance between expressions and expression vectors.]
We incrementally build up to the definition of distance between substitutions
below:

\begin{description}
  % \item[Distance between intervals.] For any two closed bounds, we write $i
  % \sim_0 i$ or $i \sim_{\infty} i'$ for $i \not= i'$. 
  %
  \item[Distance between expressions.] For any two closed expressions $e_0, e_1$
  falling in same type relation $e_0, e_1 \in R_\tau$ (where $\tau$ is a closed
  type), we can write $e_0 \sim_r e_1$ where $\mathcal{SD}_{\tau}(e_0, e_1) \leq
  r$. 

  \item[Distance between expression vectors.]
    Generally, we can write vectors of expressions (e.g. for substitutions) 
    % $\sigma =
    % \sigma_{\Delta} \ | \ \sigma_{\Gamma}, \sigma' = \sigma'_{\Delta} \ | \
    % \sigma'_{\Gamma}$
    for a given typing context $\Delta \ | \ \Gamma$ such that: $\sigma \sim_{\gamma} \sigma' : \Delta \ | \ \Gamma$ for a \textit{distance vector}
    $\gamma = r_0, r_1, \ldots$
    where
    $\sigma = \sigma_{\Delta}, e_0,~\ldots,~e_n$ 
    and 
    $\sigma' = \sigma_{\Delta}, e'_0,~\ldots,~e'_n$ 
    such that:
    $$
    e_0 \sim_{r_0} e'_0 : \tau_0~[\sigma_{\Delta}],
    ~\ldots,
    ~e_n \sim_{r_n} e'_n : \tau_n~[\sigma_{\Delta}]
    $$
    where $\sigma_{\Delta}$ is a interval vector with no free varaibles.
    Note that the distance between expression vectors are undefined when the
    interval vector $\sigma_{\Delta}$ differs between substitutions.

    We also say that a substitution vector 
    $$\sigma_{\Delta}, [e_0/x_0, \ldots, e_n/x_n]$$
    is \textit{compatible} with a typing context 
    $x_0 : \tau_0, \ldots, x_n : \tau_n$
    if each term 
    $e_0 \in \mathcal{R}_{\tau_0~[\sigma_{\Delta}]}, 
    \ldots,
    e_n \in \mathcal{R}_{\tau_n~[\sigma_{\Delta}]}$ where all types are closed by the interval vector $\sigma_{\Delta}$.
\end{description}
\end{definition}

\begin{definition}[Dot product of distance vectors.]
Our definition for the dot product of a distance vector $\gamma = r_0, \ldots,
r_n$ with respect to a context $\Gamma$ with sensitivities $s_0, \ldots, s_n$ is
the same as Fuzz \cite{Fuzz}: $\gamma \cdot \Gamma = \Sigma_{i = 1}^n r_i s_i$.
\end{definition}

In the remainder of the paper, we'll treat and represent our distance vector
$\gamma$ as a lookup function and assume that there is an implicit fixed
ordering on the variables.
\begin{definition}[Distance vector lookup.]
  We write, for a distance vector $\gamma$ and variable $x$, $\gamma(x)$ for the
  lookup of the distance of variable $x$ in $\gamma$. If the variable $x$ is not
  in the domain, $\gamma(x) = 0$ by default. 
\end{definition}

We are now ready to state the interface for soundly instantiating Numerical
Fuzz. Numerical Fuzz is a modular family of programming langauges paramterized
by the appropriate $\rho$, constant parameter $u$, and the appropriate set of
numeric computations $\Sigma$.  
% We can now state a few assumptions about how the operational and static
% semantics of $\mathbf{rnd}$ and $\Sigma$ (for $\mathbf{op}$) relate.
It is the proof obligation for any language designer instantiating the language
to demonstrate that these properties hold in order for our paramterized
soundness theorems to follow.
\begin{definition}[Interface for instantiating Numerical Fuzz.]
  \label{def:numfuzz-interface}
  The interface for Numerical Fuzz consists of  $\textit{num}$,
  $d_\textbf{num}$, $\rho$, $u$, $\Sigma$, and $\Sigma_{\mathbf{bnd}}$ such that
  the following properties hold: 
\begin{description}
  \item[a) The set \textit{num} and distance function $d_\textbf{num}$ form a
  metric space.]
  \item[b) Property of $\rho$ and constant parameter $u$.] We assume that the
    $\forall k \in \textit{num}, d_{\mathbf{num}}(\rho(k), k)
    \leq u$ where $u$ is the grade in the $\mathbf{rnd}$ typing rule.
  \item[c) Property of $\mathbf{op}$: metric preservation.] 
    We can view $\textit{op}$ as a (possibly constant) metalevel function.
    We also assume that for every operation
    $\mathbf{op} : \tau \in \ \Sigma$ we have a
    corresponding function $op$ mapping syntactic values in
    $\mathcal{VR}_{\tau}$ where metric preservation holds: For all $\sigma
    \sim_{\gamma} \sigma' : \Gamma$, $\textit{op}~\sigma \sim_{\gamma \cdot
    \Gamma} \textit{op} : \tau$.
    Or, expanded:
    \begin{description}
      \item[\underline{1) Type denotation.}] $\mathit{op} \in
        \mathcal{R}_{\tau}$. The metalevel operation will step to something in the
        value relation.
      \item[\underline{2) Context sensitivity.}]
        This property states that for every $\textbf{op}$, the
        corresponding $\textit{op}$ preserves the metric. For any two
        substitutions $\sigma, \sigma'$ such that:
        $\sigma \sim_{\gamma} \sigma' : \Gamma$
        we have that
        $\mathcal{SD}_{\tau}(\textit{op}~\sigma, \textit{op}~\sigma') \leq \gamma \cdot \Gamma$.
    \end{description} 
    \item[d) Property of $\mathbf{iop}$: closure over intervals ($\textit{num}^2$).] We further need to
      assume that for every operation $\mathbf{iop}_c : \Sigma_\textbf{num}$, we
      have that for any sequence of bounds $b_0, b_1, \ldots : \textbf{bnd}$ the
      corresponding metalevel function will actually map concrete bounds to concrete bounds
      where 
      $\textit{iop}_c((k'_0, k'_1), \ldots, (k'_n, k'_n)) = (k_0, k_1) : \textbf{bnd}$
      holds.
  % \item[c) Property of $\mathbf{op}$: metric preservation.] 
  %   We can view $\textit{op}$ as a (possibly constant) metalevel function.
  %   We also assume that for every operation
  %   $\mathbf{op} : \tau \in \ \Sigma$ we have a
  %   corresponding function $op$ mapping syntactic values in
  %   $\mathcal{VR}_{\tau}$ where metric preservation holds: For all $\sigma
  %   \sim_{\gamma} \sigma' : \Gamma$, $\textit{op}~\sigma \sim_{\gamma \cdot
  %   \Gamma} \textit{op} : \tau$.
  %   Or, expanded:
  %   \begin{description}
  %     \item[\underline{1) Type denotation.}] $\mathit{op} \in
  %       \mathcal{R}_{\tau}$. The metalevel operation will step to something in the
  %       value relation.
  %     \item[\underline{2) Context sensitivity.}]
  %       This property states that for every $\textbf{op}$, the
  %       corresponding $\textit{op}$ preserves the metric. For any two
  %       substitutions $\sigma, \sigma'$ such that:
  %       $\sigma \sim_{\gamma} \sigma' : \Gamma$
  %       we have that
  %       $\mathcal{SD}_{\tau}(\textit{op}~\sigma, \textit{op}~\sigma') \leq \gamma \cdot \Gamma$.
  %   \end{description} 
  %   \item[d) Property of $\mathbf{iop}$: closure over intervals ($\textit{num}^2$).] We further need to
  %     assume that for every operation $\mathbf{iop}_c : \Sigma_\textbf{num}$, we
  %     have that for any sequence of bounds $b_0, b_1, \ldots : \textbf{bnd}$ the
  %     corresponding metalevel function will actually map concrete bounds to concrete bounds
  %     where 
  %     $\textit{iop}_c((k'_0, k'_1), \ldots, (k'_n, k'_n)) = (k_0, k_1) : \textbf{bnd}$
  %     holds.
\end{description}
\end{definition}

\subsection{Logical Relation} \label{sec:logical-relation}
In our language, we only reason about closed types and terms. Let $CV(\tau)$ be
the closed values of type $\tau$ and $CE(\tau)$ be the closed expressions of
type $\tau$. Then we can define a unary logical relation over types which
capture the core information needed to prove our error soundness theorem.

\begin{definition}[Logical relation]
  \begin{equation}
  \begin{aligned}[c]
    \mathcal{R_{\tau}} &\triangleq 
      \{ e \ | \ e \in CE(\tau) \text{ and } \exists v
        \in CV(\tau) \text{ s.t. } e \mapsto^{*} v \text{ and } v \in \mathcal{VR_{\tau}} 
      \} \\
    \mathcal{VR_{\mathbf{unit}}} &\triangleq \{ \langle \rangle \} \\
    \mathcal{VR}_{\mathbf{num}_{b}} &\triangleq 
      \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} 
      \hspace{22em} \text{if } b \mapsto^* (k_0, k_1) \\
    \mathcal{VR}_{\mathbf{num}_{(k_0, k_1)}} &\triangleq 
      \{ r \ | \ r \in \mathit{num} \text{ and } k_0 \leq r \leq k_1 \} \\
    \mathcal{VR_{\mathbf{\tau_0 \times \tau_1}}} &\triangleq 
      \{ \langle v, w \rangle \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 \otimes \tau_1}}} &\triangleq 
      \{ ( v, w ) \ | 
        \ v \in \mathcal{R}_{\tau_0} \text{ and } w \in \mathcal{R}_{\tau_1}
      \} \\
    \mathcal{VR_{\mathbf{\tau_0 + \tau_1}}} &\triangleq 
      \{ \mathbf{inl}~v \ | \ v \in \mathcal{R}_{\tau_0} \} 
      \cup
      \{ \mathbf{inr}~v \ | \ v \in \mathcal{R}_{\tau_1} \} \\
    \mathcal{VR_{\mathbf{\tau_0 \multimap \tau_1}}} &\triangleq 
      \{ \lambda x . e \ | \ \forall w_0, w_1 \in \mathcal{VR}_{\tau_0}, \\ & \quad \quad \ (\lambda x.e)~w_0, (\lambda x . e)~w_1 \in
      \mathcal{R}_{\tau_1} \text{ and } \mathcal{SD}_{\tau_1}((\lambda x . e)~w_0, (\lambda x . e)~w_1) \leq
      \mathcal{SD}_{\tau_0}(w_0, w_1) \} \\
    \mathcal{VR_{\mathbf{!_s \tau}}} &\triangleq 
      \{ [~v~] \ | \ v \in \mathcal{R}_{\tau} \} \\
    % spicy hot new stuff
    \mathcal{VR_{\mathbf{M_q \tau}}} &\triangleq 
      \{ (v, w) \ | \ v, w \in \mathcal{R}_{\tau} \text{ and } \mathcal{SDV}_{\tau}(v, w)
      \leq q \} \\
    \mathcal{VR}_{\textbf{bnd}} &\triangleq \{ (k_0, k_1) \ | \ k_0 \leq k_1 \ \forall k_0, k_1 \in
    \textit{ num } \} \\
    \mathcal{VR_{\forall \epsilon. \tau}} &\triangleq 
      \{ ((k_0, k_1), v) \ | \ \forall (k_0, k_1) \in
      \mathcal{VR}_{\textbf{bnd}} \text{ s.t. } v ~ \{(k_0, k_1)\} \in
      \mathcal{R}_{\tau[(k_0, k_1) / \epsilon]}\} \\
  \end{aligned}
  \end{equation}
\end{definition}

\subsection{Soundness} \label{sec:soundness}
\begin{lemma}[$\mathcal{SD}$ is a metric]
  $\mathcal{SD}$ forms a metric over our syntactic terms; in particular it
  satisfies:
  \begin{enumerate}
    \item Distance from any point to itself is zero: $\forall x,~\mathcal{SD}(x,
      x) = 0$.
    \item Positivity: $\forall x, y,~\mathcal{SD}(x, y) \geq 0$.
    \item Symmetry: $\forall x, y,~\mathcal{SD}(x, y) = \mathcal{SD}(y, x)$.
    \item Triangle inequality: $\forall x, y, z,~\mathcal{SD}(x, z) \leq
      \mathcal{SD}(x, y) + \mathcal{SD}(y, z)$.
  \end{enumerate}
\end{lemma}
\begin{proof}
  The properties holds for the base cases of $\mathcal{SDV}$ and follow for the
  remaining cases by our inductive hypothesis. Since our operational semntics is
  deterministic, the properties follow for $\mathcal{SD}$.
\end{proof}

\begin{lemma}[$\mathcal{SD}$ is preserved under stepping]
  If $e_0 \mapsto e'_0$, then for any $e_1$, $\mathcal{SD}(e_0, e_1) =
  \mathcal{SD}(e'_0, e_1)$.
\end{lemma}
\begin{proof}
  Holds by inspection of the definition of $\mathcal{SD}$.
\end{proof}
Note that by metric symmetry, $\mathcal{SD}$ is preserved under stepping on both
sides.

\input{sections/05-type-error-soundness.tex}
